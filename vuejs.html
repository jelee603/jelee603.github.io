<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="viewport-fit=cover"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/6eca03e35c9c9eae.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6eca03e35c9c9eae.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-63157d71ad419e09.js" defer=""></script><script src="/_next/static/chunks/main-63b5e73f15fce3bf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-220f73948b70f663.js" defer=""></script><script src="/_next/static/chunks/23-1e1b6cd9f6a2e676.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-7d709a5d09fee3dd.js" defer=""></script><script src="/_next/static/n1F0CVZ8gd7T38i1_wAcz/_buildManifest.js" defer=""></script><script src="/_next/static/n1F0CVZ8gd7T38i1_wAcz/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="sc-45b68ef7-0 ieAueO"><nav class="sc-45b68ef7-1 cDSFRs"><div class="sc-45b68ef7-2 iKGhce"><a href="/">Home</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/React/react-condition">React</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/Vue/vuejs">Vue</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/JavaScript/es6">JavaScript</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/TypeScript/typescript">TypeScript</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/HTML_CSS/browser-operation">HTML/CSS</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/ToyProject">Toy Project</a></div><a href="/profile"><div class="sc-45b68ef7-3 TXhNy"></div></a></nav></header><section class="sc-53569208-0 qXGRu"><h1 class="sc-53569208-1 kqSQaB">Vue 이야기</h1><h6>2019-08-14</h6><article class="sc-53569208-2 lhbsva"><p>MVC 패턴이 도입되면서 Controller 에서 데이터 작업들에 대한 역할 분담을 해왔고,
Vue 는 MVVM 패턴으로 중간에 ViewModel 객체를 두고 데이터에 대한 의존성을 분리하기 위해 사용한 패턴이다.
같은 데이터인데 몇가지 조합해서 가공이 필요한 경우에 View Model 부분에서 수정을 하게끔 정해져있다.
(Dom listener, Directives, Data Binding 등등..)</p>
<ul>
<li>렌더링은 React 랑 유사하고 Virtual DOM 을 사용해서 가볍고 빠름.</li>
<li>양방향 데이터 바인딩 (Vue 인스턴스와 Template) 이 모두 데이터에 접근할 수 있음. (v-model)</li>
<li>뷰는 인스턴스가 생성되면 데이터 바인딩을 할 동안 루트요소의 모든 자식 노드를 탐색하면서 데이터 변경에 반응함.</li>
<li>뷰는 DOM 을 비동기적으로 업데이트하고 <code>Vue.nextTick(callback)</code> 을 사용하면 업데이트된 이후를 보장할 수 있음.</li>
</ul>
<p>그런데 이러한 계층 구조는 데이터 뿐만 아니라. 컴포넌트 상에서도 접목된다.</p>
<p>그 이후로 컴포넌트라는 개념이 자리잡았고, 비지니스 로직과 View 로직이 분리되면서 HTML 작업만 따로 작업을 할 수도 있게 되었다.
그러면서 공통적으로 사용할 UI 인 경우엔 컴포넌트로 분리하고 필요하면 데이터만 변경해서 사용할 수 있게 만들어 놓게 되었다.</p>
<p>그리고 이렇게 발전한 사용법으로 Vue 를 접했을 땐, 자식 컴포넌트는 이미 부모 레벨의 정보를 들고 있을 수 있게 되었단걸 알게 되었다.</p>
<h4>부모에서 자식 계층으로 정보를 전달하는 방법은?</h4>
<p>공통 컴포넌트라고 하면 보통은 제일 마지막 자식 계층일 경우가 많다.
그래서 이 계층에서는 mounted 에서 부모의 clientHeight 를 구해올 수 있다.</p>
<pre><code>this.$parent;
this.$el.parent;
</code></pre>
<h4>Vue Component 에 타입스크립트 해서 적용해본 사례는?</h4>
<p>SFC(Single File Component) 는 Vue가 권장하는 Vue 컴포넌트 전용 파일 포맷이다. 한 파일 안에 템플릿과 자바스크립트 그리고 CSS까지 정의한다.
개발자가 클래스를 정의하기보다는 클래스를 만들 수 있는 옵션을 정의하는 형태로 개발한다.
엄격한 타입의 언어를 다루던 개발자들이 자바스크립트를 다뤄야할때 완충 역할로 타입스크립트를 사용했고,
타입은 어플리케이션 설계 전체에 영향을 주는 것이라 필요하게 되었다라고 말하는 <a href="https://ui.toast.com/weekly-pick/ko_20190327/">shiren</a>님의 글을 보게 되었다는데 아마
상당한 시행착오를 겪은 걸 보고, 우리도 Vue3로 전환하면 사용하게 될 거 같다는 생각이 든다.</p>
<h3>Vue Test Util</h3>
<p><a href="https://joshua1988.github.io/vue-camp/testing/vue-test-util.html#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%84%A4%EC%B9%98">joshua</a> 님 블로그에 보면, vue-cli 로 자동으로 설치가 된다하였지만, 기존에 만들었던 프로젝트는 vue-cli(2.x) 이라 모듈 설치방법으로 진행해봤다.
jest 라이브러리 설치</p>
<pre><code>npm install jest @vue/test-utils vue-jest babel-jest --save-dev
</code></pre>
<h4>ESLint 적용하기</h4>
<p>standard 를 사용해보고 싶어서 적용했고, indent만 4칸만 지정했다.
<code>npm run eslint --fix</code> 로 사용이 가능하다.</p>
<pre><code>// 기본설치
npm install -D --save eslint eslint=plugin-vue

// 추가사항
npm install -D --save eslint-plugin-import
npm install -D --save eslint-plugin-node
npm install -D --save eslint-plugin-promise
npm install -D --save eslint-plugin-standard
</code></pre>
<p>indent 만 설정한 기본 파일로 세팅했다.</p>
<pre><code>// .eslint.js

module.exports = {
  root: true,
  extends: ['standard', 'plugin:vue/recommended'],
  rules: {
    indent: ['error', 4],
  },
};
</code></pre>
<h4>Child 의 이벤트를 전달하는 방법 (EventBus)</h4>
<pre><code>// Child.vue
&#x3C;template>
    &#x3C;div>
        &#x3C;input @input="event => this.$emit('inputChange', event)" />
    &#x3C;/div>
&#x3C;/template>

// Parent.vue
&#x3C;template>
    &#x3C;div>
        &#x3C;Child v-on:inputChange="handleChange" />
        &#x3C;p>Value: {{value}}&#x3C;/p>
    &#x3C;/div>
&#x3C;/template>
&#x3C;script>
    import Child from './Child.vue'

    export default {
        data() {
            return {
                value: '',
            };
        },
        components: {
            Child,
        },
        methods: {
            handleChange(event) {
                const { value } = event.target;
                this.value = value;
            }
        }
    }
&#x3C;/script>
</code></pre>
<p>v-on:inputChange 는 심플하게 @inputChange 이렇게 사용할 수 있고,
@input 입력이 되면, Parent 의 handleChange 메서드에 값이 전달된다.
이걸 내 방법으로 표현하면, <code>this.$emit('inputChange', event)</code> 이벤트 명을 정해주면 hook 이 걸려서
동작한 값을 해당 이벤트 명에 전달해줄 수 있다는 의미가 될 수 있겠다.</p>
<p>출처: https://stackoverflow.com/questions/40915436/vuejs-update-parent-data-from-child-component</p>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Vue 이야기","slug":"vuejs","date":"2019-08-14","content":"\u003cp\u003eMVC 패턴이 도입되면서 Controller 에서 데이터 작업들에 대한 역할 분담을 해왔고,\nVue 는 MVVM 패턴으로 중간에 ViewModel 객체를 두고 데이터에 대한 의존성을 분리하기 위해 사용한 패턴이다.\n같은 데이터인데 몇가지 조합해서 가공이 필요한 경우에 View Model 부분에서 수정을 하게끔 정해져있다.\n(Dom listener, Directives, Data Binding 등등..)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e렌더링은 React 랑 유사하고 Virtual DOM 을 사용해서 가볍고 빠름.\u003c/li\u003e\n\u003cli\u003e양방향 데이터 바인딩 (Vue 인스턴스와 Template) 이 모두 데이터에 접근할 수 있음. (v-model)\u003c/li\u003e\n\u003cli\u003e뷰는 인스턴스가 생성되면 데이터 바인딩을 할 동안 루트요소의 모든 자식 노드를 탐색하면서 데이터 변경에 반응함.\u003c/li\u003e\n\u003cli\u003e뷰는 DOM 을 비동기적으로 업데이트하고 \u003ccode\u003eVue.nextTick(callback)\u003c/code\u003e 을 사용하면 업데이트된 이후를 보장할 수 있음.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그런데 이러한 계층 구조는 데이터 뿐만 아니라. 컴포넌트 상에서도 접목된다.\u003c/p\u003e\n\u003cp\u003e그 이후로 컴포넌트라는 개념이 자리잡았고, 비지니스 로직과 View 로직이 분리되면서 HTML 작업만 따로 작업을 할 수도 있게 되었다.\n그러면서 공통적으로 사용할 UI 인 경우엔 컴포넌트로 분리하고 필요하면 데이터만 변경해서 사용할 수 있게 만들어 놓게 되었다.\u003c/p\u003e\n\u003cp\u003e그리고 이렇게 발전한 사용법으로 Vue 를 접했을 땐, 자식 컴포넌트는 이미 부모 레벨의 정보를 들고 있을 수 있게 되었단걸 알게 되었다.\u003c/p\u003e\n\u003ch4\u003e부모에서 자식 계층으로 정보를 전달하는 방법은?\u003c/h4\u003e\n\u003cp\u003e공통 컴포넌트라고 하면 보통은 제일 마지막 자식 계층일 경우가 많다.\n그래서 이 계층에서는 mounted 에서 부모의 clientHeight 를 구해올 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ethis.$parent;\nthis.$el.parent;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eVue Component 에 타입스크립트 해서 적용해본 사례는?\u003c/h4\u003e\n\u003cp\u003eSFC(Single File Component) 는 Vue가 권장하는 Vue 컴포넌트 전용 파일 포맷이다. 한 파일 안에 템플릿과 자바스크립트 그리고 CSS까지 정의한다.\n개발자가 클래스를 정의하기보다는 클래스를 만들 수 있는 옵션을 정의하는 형태로 개발한다.\n엄격한 타입의 언어를 다루던 개발자들이 자바스크립트를 다뤄야할때 완충 역할로 타입스크립트를 사용했고,\n타입은 어플리케이션 설계 전체에 영향을 주는 것이라 필요하게 되었다라고 말하는 \u003ca href=\"https://ui.toast.com/weekly-pick/ko_20190327/\"\u003eshiren\u003c/a\u003e님의 글을 보게 되었다는데 아마\n상당한 시행착오를 겪은 걸 보고, 우리도 Vue3로 전환하면 사용하게 될 거 같다는 생각이 든다.\u003c/p\u003e\n\u003ch3\u003eVue Test Util\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://joshua1988.github.io/vue-camp/testing/vue-test-util.html#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%84%A4%EC%B9%98\"\u003ejoshua\u003c/a\u003e 님 블로그에 보면, vue-cli 로 자동으로 설치가 된다하였지만, 기존에 만들었던 프로젝트는 vue-cli(2.x) 이라 모듈 설치방법으로 진행해봤다.\njest 라이브러리 설치\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enpm install jest @vue/test-utils vue-jest babel-jest --save-dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eESLint 적용하기\u003c/h4\u003e\n\u003cp\u003estandard 를 사용해보고 싶어서 적용했고, indent만 4칸만 지정했다.\n\u003ccode\u003enpm run eslint --fix\u003c/code\u003e 로 사용이 가능하다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 기본설치\nnpm install -D --save eslint eslint=plugin-vue\n\n// 추가사항\nnpm install -D --save eslint-plugin-import\nnpm install -D --save eslint-plugin-node\nnpm install -D --save eslint-plugin-promise\nnpm install -D --save eslint-plugin-standard\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eindent 만 설정한 기본 파일로 세팅했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// .eslint.js\n\nmodule.exports = {\n  root: true,\n  extends: ['standard', 'plugin:vue/recommended'],\n  rules: {\n    indent: ['error', 4],\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eChild 의 이벤트를 전달하는 방법 (EventBus)\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e// Child.vue\n\u0026#x3C;template\u003e\n    \u0026#x3C;div\u003e\n        \u0026#x3C;input @input=\"event =\u003e this.$emit('inputChange', event)\" /\u003e\n    \u0026#x3C;/div\u003e\n\u0026#x3C;/template\u003e\n\n// Parent.vue\n\u0026#x3C;template\u003e\n    \u0026#x3C;div\u003e\n        \u0026#x3C;Child v-on:inputChange=\"handleChange\" /\u003e\n        \u0026#x3C;p\u003eValue: {{value}}\u0026#x3C;/p\u003e\n    \u0026#x3C;/div\u003e\n\u0026#x3C;/template\u003e\n\u0026#x3C;script\u003e\n    import Child from './Child.vue'\n\n    export default {\n        data() {\n            return {\n                value: '',\n            };\n        },\n        components: {\n            Child,\n        },\n        methods: {\n            handleChange(event) {\n                const { value } = event.target;\n                this.value = value;\n            }\n        }\n    }\n\u0026#x3C;/script\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ev-on:inputChange 는 심플하게 @inputChange 이렇게 사용할 수 있고,\n@input 입력이 되면, Parent 의 handleChange 메서드에 값이 전달된다.\n이걸 내 방법으로 표현하면, \u003ccode\u003ethis.$emit('inputChange', event)\u003c/code\u003e 이벤트 명을 정해주면 hook 이 걸려서\n동작한 값을 해당 이벤트 명에 전달해줄 수 있다는 의미가 될 수 있겠다.\u003c/p\u003e\n\u003cp\u003e출처: https://stackoverflow.com/questions/40915436/vuejs-update-parent-data-from-child-component\u003c/p\u003e\n","category":"Vue"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"vuejs"},"buildId":"n1F0CVZ8gd7T38i1_wAcz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>