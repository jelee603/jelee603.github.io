<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0 ,minimum-scale=1.0, width=device-width, viewport-fit=cover"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/d29aca3277e1bd1c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d29aca3277e1bd1c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-880e48e2fc817058.js" defer=""></script><script src="/_next/static/chunks/framework-63157d71ad419e09.js" defer=""></script><script src="/_next/static/chunks/main-2f1c90f15011e7a4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9e361426a55aee88.js" defer=""></script><script src="/_next/static/chunks/188-14e746261f892f2c.js" defer=""></script><script src="/_next/static/chunks/pages/Tip/%5Bslug%5D-63735a2a1db766cb.js" defer=""></script><script src="/_next/static/xay3d15z9E4K8RmvwBUHi/_buildManifest.js" defer=""></script><script src="/_next/static/xay3d15z9E4K8RmvwBUHi/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-146a2566-0 jjulPm"><header class="sc-939270c9-0 eRiGtL"><a href="/"><div class="sc-939270c9-1 kBNmkl"></div></a><div class="sc-939270c9-2 kFysXu"><style data-emotion="css 6flbmm">.css-6flbmm{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:2.1875rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeLarge css-6flbmm" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></div></header><main class="sc-146a2566-2 enhKzY"><section class="sc-6dd44fad-0 lgiNLW"><h1 class="sc-6dd44fad-1 kGSZzK">Javascript 디자인패턴 이야기</h1><h5 class="sc-6dd44fad-2 jQbjEf">2019-09-11</h5><article class="sc-6dd44fad-3 kLqHis"><h2>클래스란 (클래스/상속 디자인 패턴)</h2>
<p>클래스화란 데이터와 작동을 함께 잘 감싸서 캡슐화하는 것이 올바른 설계이다.
데이터에 적용 가능한 작동들을 메서드로 설계해야한다.
클래스에서는 어떤 작동이 담긴 메서드의 이름을 부모와 자식 클래스 모두 똑같이 공유하여 자식 클래스가 부모 클래스를 오바라이드하라고 권장한다.
그러나 자바스크립트에서는 이렇게 하면 불안정한 결과를 불러온다.</p>
<!-- more -->

<p>나는 대부분 절차적 프로그래밍을 해왔다는 걸 알게 되었다. 상위 추상화 없이 단순히 다른 함수를 호출해서 사용하는 방법만 사용해왔고,
클래스의 경우는 라이브러리를 통해서만 사용했었다. 그래서 편리함은 알지만, 다뤄보지 않은 영역이라 이번 기회에 다시 정리하고자 한다.</p>
<p>클래스는 복사 과정을 거쳐 객체 형태로 인스턴스화 한다.
인스턴스는 생성자가 해주는데 이 생성자는 미리 정보에 대한 변수를 초기화해준다.
항상 new 키워드를 앞에 붙여 생성자를 호출한다.</p>
<pre class = "line-numbers"><code class = "language-js"><span class="token keyword">class</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> btn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>오버라이드하기 전의 원본 메서드와 오버라이드 메서드가 다를 수도 있는데 이를 다형성(오버라이드)이라 한다.
inherits/super 라는 키워드로 사용하며, 부모/조상 중 어떤 메서드를 호출할지 결정하는 것도 다형성의 기법이다.</p>
<blockquote>
<p>자바스크립트엔 클래스란 개념 자체가 없고 오직 객체만 있다. 그래서 위와 같은 동작들은 자동으로 일어나지 않는다. <br/>
인스턴스화 해도 자동으로 복사가 되지않기 때문에 믹스인으로 클래스 복사기능을 흉내내었다.
이런 기능을 여러 라이브러리에서는 <code>extends()</code> 라 하고, 프로퍼티를 복사를 할 수 있게 제공된다.
믹스인 과정을 초콜릿 조각을 본인이 원하는 쿠키 반죽에 섞어 넣는 것에 비유한다. (이 말이 가장 기억에 남을거 같다)<br/>
&lt;You Don&#39;t Know JS: this와 객체 프로토타입, 비동기와 성능 - 카일 심슨&gt;</p>
</blockquote>
<p>이렇게 일일히 복사(믹스인) 하더라도 다른 클래스 지향처럼 100%(인스턴스) 복사는 어렵다.</p>
<h2>프로토타입이란 (프로토타입 디자인 패턴)</h2>
<p>객체를 다른 객체에 연결한다. 수평적인 상태에서 위임이 되는 연결이다.
오버라이드 하기 딱 좋은 메서드 명칭보다는 각 객체의 작동방식을 설명하는 서술적인 명칭이 필요하다.
모든 레퍼런스가 확실히 존재한다면 양방향 위임은 가능하긴 하지만 무한 루프에 빠질 수 있다.</p>
<pre class = "line-numbers"><code class = "language-js"><span class="token keyword">var</span> btn1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Button<span class="token punctuation">)</span><span class="token punctuation">;</span>
btn1<span class="token punctuation">.</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>어떤 함수가 call(), apply(), bind() 메서드에 접근할 수 있는 건 함수 자신도 객체고 함수 객체 역시 <code>Function.prototype</code>에
[[Prototype]]이 연결되어 위임 가능한 메서드가 있어 가능한 것이다.
<a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">infoscis</a>님 블로그에 예제가 잘 나와있다.</p>
<pre class = "line-numbers"><code class = "language-js"><span class="token comment">// ES6 [[Prototype]] 에 저장된 값을 변경한다.</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototyupeOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2>디자인 패턴이란</h2>
<blockquote>
<p>반복적으로 발생하는 문제와 그 문제의 해법으로 정의된다.
패턴은 유사한 상황에서 반복적으로 적용할 수 있는 책임-주도 설계의 결과물이다. <br/> 그리고 그 방법이 왜 더 효과적인지에 대한 이유를 설명한다. <br/>
&lt;객체 지향의 사실과 오해 - 조영호&gt;</p>
</blockquote>
<h3>1. Composite 패턴</h3>
<p>동일한 인터페이스를 제공해야한다는 제약하에 역할, 책임, 협력을 제공하는 설계 방법이다.</p>
<p>Leaf 의 역할은 공용 인터페이스의 협력
Client 는 Component 에게 메시지를 요청하는 역할
Component 의 역할은 다른 컴포넌트를 추가, 제거, 포함된 컴포넌트를 반환하는 역할</p>
</article></section></main></div><div id="modal"></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Javascript 디자인패턴 이야기","slug":"pattern","date":"2019-09-11","content":"\u003ch2\u003e클래스란 (클래스/상속 디자인 패턴)\u003c/h2\u003e\n\u003cp\u003e클래스화란 데이터와 작동을 함께 잘 감싸서 캡슐화하는 것이 올바른 설계이다.\n데이터에 적용 가능한 작동들을 메서드로 설계해야한다.\n클래스에서는 어떤 작동이 담긴 메서드의 이름을 부모와 자식 클래스 모두 똑같이 공유하여 자식 클래스가 부모 클래스를 오바라이드하라고 권장한다.\n그러나 자바스크립트에서는 이렇게 하면 불안정한 결과를 불러온다.\u003c/p\u003e\n\u003c!-- more --\u003e\n\n\u003cp\u003e나는 대부분 절차적 프로그래밍을 해왔다는 걸 알게 되었다. 상위 추상화 없이 단순히 다른 함수를 호출해서 사용하는 방법만 사용해왔고,\n클래스의 경우는 라이브러리를 통해서만 사용했었다. 그래서 편리함은 알지만, 다뤄보지 않은 영역이라 이번 기회에 다시 정리하고자 한다.\u003c/p\u003e\n\u003cp\u003e클래스는 복사 과정을 거쳐 객체 형태로 인스턴스화 한다.\n인스턴스는 생성자가 해주는데 이 생성자는 미리 정보에 대한 변수를 초기화해준다.\n항상 new 키워드를 앞에 붙여 생성자를 호출한다.\u003c/p\u003e\n\u003cpre class = \"line-numbers\"\u003e\u003ccode class = \"language-js\"\u003e\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eButton\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003evar\u003c/span\u003e btn1 \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eButton\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e오버라이드하기 전의 원본 메서드와 오버라이드 메서드가 다를 수도 있는데 이를 다형성(오버라이드)이라 한다.\ninherits/super 라는 키워드로 사용하며, 부모/조상 중 어떤 메서드를 호출할지 결정하는 것도 다형성의 기법이다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e자바스크립트엔 클래스란 개념 자체가 없고 오직 객체만 있다. 그래서 위와 같은 동작들은 자동으로 일어나지 않는다. \u003cbr/\u003e\n인스턴스화 해도 자동으로 복사가 되지않기 때문에 믹스인으로 클래스 복사기능을 흉내내었다.\n이런 기능을 여러 라이브러리에서는 \u003ccode\u003eextends()\u003c/code\u003e 라 하고, 프로퍼티를 복사를 할 수 있게 제공된다.\n믹스인 과정을 초콜릿 조각을 본인이 원하는 쿠키 반죽에 섞어 넣는 것에 비유한다. (이 말이 가장 기억에 남을거 같다)\u003cbr/\u003e\n\u0026lt;You Don\u0026#39;t Know JS: this와 객체 프로토타입, 비동기와 성능 - 카일 심슨\u0026gt;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이렇게 일일히 복사(믹스인) 하더라도 다른 클래스 지향처럼 100%(인스턴스) 복사는 어렵다.\u003c/p\u003e\n\u003ch2\u003e프로토타입이란 (프로토타입 디자인 패턴)\u003c/h2\u003e\n\u003cp\u003e객체를 다른 객체에 연결한다. 수평적인 상태에서 위임이 되는 연결이다.\n오버라이드 하기 딱 좋은 메서드 명칭보다는 각 객체의 작동방식을 설명하는 서술적인 명칭이 필요하다.\n모든 레퍼런스가 확실히 존재한다면 양방향 위임은 가능하긴 하지만 무한 루프에 빠질 수 있다.\u003c/p\u003e\n\u003cpre class = \"line-numbers\"\u003e\u003ccode class = \"language-js\"\u003e\u003cspan class=\"token keyword\"\u003evar\u003c/span\u003e btn1 \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e Object\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ecreate\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eButton\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\nbtn1\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003esetup\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e어떤 함수가 call(), apply(), bind() 메서드에 접근할 수 있는 건 함수 자신도 객체고 함수 객체 역시 \u003ccode\u003eFunction.prototype\u003c/code\u003e에\n[[Prototype]]이 연결되어 위임 가능한 메서드가 있어 가능한 것이다.\n\u003ca href=\"https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/\"\u003einfoscis\u003c/a\u003e님 블로그에 예제가 잘 나와있다.\u003c/p\u003e\n\u003cpre class = \"line-numbers\"\u003e\u003ccode class = \"language-js\"\u003e\u003cspan class=\"token comment\"\u003e// ES6 [[Prototype]] 에 저장된 값을 변경한다.\u003c/span\u003e\nObject\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003esetPrototyupeOf\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e디자인 패턴이란\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e반복적으로 발생하는 문제와 그 문제의 해법으로 정의된다.\n패턴은 유사한 상황에서 반복적으로 적용할 수 있는 책임-주도 설계의 결과물이다. \u003cbr/\u003e 그리고 그 방법이 왜 더 효과적인지에 대한 이유를 설명한다. \u003cbr/\u003e\n\u0026lt;객체 지향의 사실과 오해 - 조영호\u0026gt;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e1. Composite 패턴\u003c/h3\u003e\n\u003cp\u003e동일한 인터페이스를 제공해야한다는 제약하에 역할, 책임, 협력을 제공하는 설계 방법이다.\u003c/p\u003e\n\u003cp\u003eLeaf 의 역할은 공용 인터페이스의 협력\nClient 는 Component 에게 메시지를 요청하는 역할\nComponent 의 역할은 다른 컴포넌트를 추가, 제거, 포함된 컴포넌트를 반환하는 역할\u003c/p\u003e\n","category":"JavaScript"},"posts":[{"slug":"css-semantic","title":"시맨틱 태그 (Semantic Tag)","date":"2023-08-24","coverImage":"/images/cover/default.png","category":"HTML_CSS"},{"slug":"react-portal","title":"React Portal","date":"2023-08-24","coverImage":"/images/cover/default.png","category":"React"},{"slug":"blog-next","title":"Next.js로 마크다운 블로그 만들기","date":"2023-08-22","coverImage":"/images/cover/blog_next.png","category":"ToyProject"},{"slug":"css-unit","title":"CSS 단위","date":"2023-08-21","coverImage":null,"category":"HTML_CSS"},{"slug":"hello-world","title":"Hello","date":"2023-08-16"},{"slug":"shortcut-mac","title":"Mac을 편하게 사용하는 방법 7가지","date":"2022-04-06 23:00:14","coverImage":"/images/cover/shortcut-mac.png","category":"Tip"},{"slug":"react-native","title":"React Native","date":"2022-03-17 14:00:00","coverImage":"/images/cover/react-native.png","category":"React"},{"slug":"modern-js","title":"모던 자바스크립트 새로운 기능","date":"2022-01-27 23:47:36","coverImage":"/images/cover/modern-js.png","category":"JavaScript"},{"slug":"codespitz-86","title":"코드스피츠 [객체지향 자바스크립트] 돌아보기","date":"2022-01-27 21:11:37","coverImage":"/images/cover/codespitz.png","category":"JavaScript"},{"slug":"eslint-prettier","title":"VSCode 에서 ESLint와 Prettier 설정방법","date":"2022-01-15 17:05:58","coverImage":"/images/cover/eslint-prettier.png","category":"Tip"},{"slug":"typescript-config","title":"TSConfig 설정방법","date":"2022-01-14 16:14:08","coverImage":"/images/cover/typescript-config.png","category":"TypeScript"},{"slug":"react-cypress","title":"React에 Cypress 적용하기","date":"2022-01-14 13:58:02","coverImage":"/images/cover/react-cypress.png","category":"React"},{"slug":"react-runtime-error","title":"React에서 만난 오류들","date":"2021-12-28 14:57:17","coverImage":"/images/cover/react-runtime-error.png","category":"React"},{"slug":"browser-operation","title":"브라우저 동작 원리","date":"2021-12-01 21:59:43","coverImage":"/images/cover/browser-operation.png","category":"HTML_CSS"},{"slug":"react-redux","title":"React와 Redux","date":"2021-11-26 13:45:56","coverImage":"/images/cover/react-redux.png","category":"React"},{"slug":"css-selectors","title":"CSS 선택자","date":"2021-11-12 15:12:23","coverImage":"/images/cover/css-selectors.png","category":"HTML_CSS"},{"slug":"html-span","title":"HTML \u003cspan\u003e 요소","date":"2021-11-12 15:08:11","coverImage":"/images/cover/html-span.png","category":"HTML_CSS"},{"slug":"create-thumbnail","title":"썸네일 이미지 생성","date":"2021-11-10 17:55:44","coverImage":"/images/cover/create-thumbnail.png","category":"ToyProject"},{"slug":"react-migration","title":"React 기존 프로젝트에 타입스크립트 마이그레이션","date":"2021-11-05 00:22:39","coverImage":"/images/cover/react-migration.png","category":"React"},{"slug":"react-vac","title":"React VAC Pattern","date":"2021-11-01 16:57:17","coverImage":"/images/cover/react-vac.png","category":"React"},{"slug":"typescript","title":"TypeScript 스터디","date":"2021-11-01 14:27:36","coverImage":"/images/cover/typescript.png","category":"TypeScript"},{"slug":"vanilla","title":"Vanilla JS 다뤄보기","date":"2021-10-30 23:20:00","coverImage":"/images/cover/vanilla.png","category":"JavaScript"},{"slug":"yarn","title":"Yarn","date":"2021-10-17 15:31:01","coverImage":"/images/cover/yarn.png","category":"JavaScript"},{"slug":"port","title":"Mac에서 Port 종료하기","date":"2021-10-10 23:31:07","coverImage":"/images/cover/port.png","category":"Tip"},{"slug":"react-condition","title":"React 조건부 렌더링","date":"2021-10-03 18:38:26","coverImage":"/images/cover/react-condition.png","category":"React"},{"slug":"load-map","title":"로드맵","date":"2021-09-24 14:39:08","coverImage":"/images/cover/default.png","category":"ToyProject"},{"slug":"blog-hexo","title":"Hexo를 이용한 github 블로그 만들기","date":"2021-09-24","coverImage":"/images/cover/blog-hexo.png","category":"ToyProject"},{"slug":"good-image","title":"good-image","date":"2021-09-13 12:59:37","coverImage":"/images/cover/study.png"},{"slug":"es6","title":"ES6 문법","date":"2020-02-04","coverImage":"/images/cover/es6.png","category":"JavaScript"},{"slug":"sass","title":"Sass(SCSS) 알아가기","date":"2020-01-22","coverImage":"/images/cover/sass.png","category":"HTML_CSS"},{"slug":"shortcut","title":"단축키 모음","date":"2020-01-09","coverImage":"/images/cover/vscode.png","category":"Tip"},{"slug":"storage","title":"Local \u0026 Session Storage","date":"2019-11-01","coverImage":"/images/cover/storage.png","category":"HTML_CSS"},{"slug":"testing-vue","title":"Vue.js 2.x 테스트 적용기","date":"2019-10-17","coverImage":"/images/cover/testing-vue.png","category":"Vue"},{"slug":"graphql","title":"Graphql 적용기","date":"2019-10-16","coverImage":"/images/cover/graphql.png","category":"JavaScript"},{"slug":"blob","title":"Load Image File","date":"2019-10-10","coverImage":"/images/cover/blob.png","category":"JavaScript"},{"slug":"d3","title":"D3 필요한 메서드 정리해보자","date":"2019-10-01","coverImage":"/images/cover/d3.png","category":"JavaScript"},{"slug":"settings","title":"개발환경 세팅하기","date":"2019-09-26","coverImage":"/images/cover/settings.png","category":"Tip"},{"slug":"pattern","title":"Javascript 디자인패턴 이야기","date":"2019-09-11","coverImage":"/images/cover/pattern.png","category":"JavaScript"},{"slug":"promise","title":"Javascript Promise 이야기","date":"2019-08-28","coverImage":"/images/cover/promise.png","category":"JavaScript"},{"slug":"event","title":"Javascript Event 이야기","date":"2019-08-22","coverImage":"/images/cover/event.png","category":"JavaScript"},{"slug":"object","title":"Javascript Object 이야기","date":"2019-08-21","coverImage":"/images/cover/object.png","category":"JavaScript"},{"slug":"browser","title":"Browser 이야기","date":"2019-08-19","coverImage":"/images/cover/browser.png","category":"HTML_CSS"},{"slug":"array","title":"Javascript Array 이야기","date":"2019-08-18","coverImage":"/images/cover/array.png","category":"JavaScript"},{"slug":"css-grid-flex","title":"Grid 와 Flex 사용법","date":"2019-08-16","coverImage":"/images/cover/css-grid-flex.png","category":"HTML_CSS"},{"slug":"vuejs","title":"Vue 이야기","date":"2019-08-14","coverImage":"/images/cover/vue-js.png","category":"Vue"},{"slug":"npm","title":"NPM","date":"2019-08-09","coverImage":"/images/cover/npm.png","category":"JavaScript"},{"slug":"git","title":"안 쓰면 잊어버리는 Git 명령어","date":"2019-08-08","coverImage":"/images/cover/git.png","category":"Tip"},{"slug":"blog-jekyll","title":"Jekyll을 이용한 github 블로그 만들기","date":"2019-08-07","coverImage":"/images/cover/blog-jekyll.png","category":"ToyProject"},{"slug":"canvas","title":"Canvas로 그래프 그리기","date":"2019-06-10","coverImage":"/images/cover/canvas.png","category":"HTML_CSS"}]},"__N_SSG":true},"page":"/Tip/[slug]","query":{"slug":"pattern"},"buildId":"xay3d15z9E4K8RmvwBUHi","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>