<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="viewport-fit=cover"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/6eca03e35c9c9eae.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6eca03e35c9c9eae.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-63157d71ad419e09.js" defer=""></script><script src="/_next/static/chunks/main-63b5e73f15fce3bf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-220f73948b70f663.js" defer=""></script><script src="/_next/static/chunks/23-1e1b6cd9f6a2e676.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-7d709a5d09fee3dd.js" defer=""></script><script src="/_next/static/n1F0CVZ8gd7T38i1_wAcz/_buildManifest.js" defer=""></script><script src="/_next/static/n1F0CVZ8gd7T38i1_wAcz/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="sc-45b68ef7-0 ieAueO"><nav class="sc-45b68ef7-1 cDSFRs"><div class="sc-45b68ef7-2 iKGhce"><a href="/">Home</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/React/react-condition">React</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/Vue/vuejs">Vue</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/JavaScript/es6">JavaScript</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/TypeScript/typescript">TypeScript</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/HTML_CSS/browser-operation">HTML/CSS</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/ToyProject">Toy Project</a></div><a href="/profile"><div class="sc-45b68ef7-3 TXhNy"></div></a></nav></header><section class="sc-53569208-0 qXGRu"><h1 class="sc-53569208-1 kqSQaB">Canvas로 그래프 그리기</h1><h6>2019-06-10</h6><article class="sc-53569208-2 lhbsva"><p>Grid 내부에 그래프를 그려야하는데 캔버스와 SVG, DIV 방법이 있을 수 있는데 어느 것을 골라야할지 망설여졌다.
분명 성능 이슈가 있겠지? 그래서 성능면에서 어떤 차이가 있는지부터 먼저 찾아보기로 했다.</p>
<hr>
<h4>SVG 와 Canvas의 장단점</h4>
<p><strong>SVG</strong></p>
<ul>
<li>복잡하지 않게 사용자 인터렉션이 가능합니다. (클릭, 마우스오버 이벤트 포함)</li>
<li>모든 엘리먼트는 DOM에 부착되어 자바스크립트와 CSS 통해 변형이 가능하며 텍스트를 지원한다.</li>
<li>DOM 방식보다는 시간이 오래걸립니다.</li>
<li>성능은 화면이 크거나, 픽셀 수가 적을 경우(&#x3C;10k) 에 좋습니다.</li>
<li>고품질 문서 작업이나 정적 이미지의 조작 작업 등에 어울립니다.</li>
<li>스크립트와 CSS를 통해서도 수정할 수 있음</li>
</ul>
<p><strong>Canvas</strong></p>
<ul>
<li>단순한 그래픽 API로 픽셀 이상을 나타내기 어렵습니다.</li>
<li>화면상 다른 동작을 할때도 전혀 부담이 없습니다.</li>
<li>빠른 응답속도와 메모리 과부하가 가장 적습니다.</li>
<li>성능은 화면이 작거나, 픽셀 수가 많을 경우(>10k) 에 좋습니다.</li>
<li>고성능의 애니메니션 작업이나 동영상 조작 등의 작업에 어울립니다.</li>
<li>스크립트를 통해서만 수정할 수 있음</li>
</ul>
<p>캔버스는 그래픽이 잘 동작하고 성능이 저하되지 않도록 엘리먼트 사용을 최적화할 수 있는 방법이다.</p>
<hr>
<h4>성능 비교</h4>
<p>1px dom 25만개를 그렸을때 걸리는 시간에 대한 <a href="https://medium.com/@idchoi2/javascript-%EB%8F%84%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0-html-vs-svg-vs-canvas-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-9e1ce2396fcd">idchoi2</a>
님의 글을 읽어보고 나니.. 렌더링 시간이 확연히 차이가 있었다.</p>
<p>|          | 렌더링 시간          | 메모리 사용량 |
| -------- | -------------------- | ------------- |
| HTML DOM | 4356.28ms (3~4초)    | 796.3M        |
| SVG      | 7799.06ms (6~7초)    | 1.7G          |
| Canvas   | 430.71ms (0.3~0.4초) | 217.6M        |</p>
<hr>
<h4>결론</h4>
<p>그래서 렌더링 속도가 빠른 캔버스로 그려봤다.</p>
<pre><code>const draw = (curr) => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const tot = 1000;
  const percent = Math.floor((curr / tot) * 100);
  const height = 25;

  if (this.width === null) {
    this.width = document.querySelectorAll('th')[2].clientWidth;
  }
  const width = this.width * (percent / 100);

  canvas.width = width + 50;
  canvas.height = height;
  ctx.fillStyle = 'green';
  ctx.font = '10px Aria';
  ctx.fillRect(0, 0, width, height);
  ctx.fillStyle = 'white';

  // 퍼센트값
  ctx.fillText(`${percent}%`, 8, height - 10);
  ctx.textAlign = 'right';

  // 실제값
  ctx.fillText(curr, width + 30, height - 10);
  ctx.textAlign = 'left';

  return canvas;
};
</code></pre>
<p><strong>결과</strong>
<img src="/img/post-2019-06-10-1.png" alt="canvas">{:width="100%" height="50%"}</p>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Canvas로 그래프 그리기","slug":"canvas","date":"2019-06-10","content":"\u003cp\u003eGrid 내부에 그래프를 그려야하는데 캔버스와 SVG, DIV 방법이 있을 수 있는데 어느 것을 골라야할지 망설여졌다.\n분명 성능 이슈가 있겠지? 그래서 성능면에서 어떤 차이가 있는지부터 먼저 찾아보기로 했다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch4\u003eSVG 와 Canvas의 장단점\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eSVG\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e복잡하지 않게 사용자 인터렉션이 가능합니다. (클릭, 마우스오버 이벤트 포함)\u003c/li\u003e\n\u003cli\u003e모든 엘리먼트는 DOM에 부착되어 자바스크립트와 CSS 통해 변형이 가능하며 텍스트를 지원한다.\u003c/li\u003e\n\u003cli\u003eDOM 방식보다는 시간이 오래걸립니다.\u003c/li\u003e\n\u003cli\u003e성능은 화면이 크거나, 픽셀 수가 적을 경우(\u0026#x3C;10k) 에 좋습니다.\u003c/li\u003e\n\u003cli\u003e고품질 문서 작업이나 정적 이미지의 조작 작업 등에 어울립니다.\u003c/li\u003e\n\u003cli\u003e스크립트와 CSS를 통해서도 수정할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCanvas\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단순한 그래픽 API로 픽셀 이상을 나타내기 어렵습니다.\u003c/li\u003e\n\u003cli\u003e화면상 다른 동작을 할때도 전혀 부담이 없습니다.\u003c/li\u003e\n\u003cli\u003e빠른 응답속도와 메모리 과부하가 가장 적습니다.\u003c/li\u003e\n\u003cli\u003e성능은 화면이 작거나, 픽셀 수가 많을 경우(\u003e10k) 에 좋습니다.\u003c/li\u003e\n\u003cli\u003e고성능의 애니메니션 작업이나 동영상 조작 등의 작업에 어울립니다.\u003c/li\u003e\n\u003cli\u003e스크립트를 통해서만 수정할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e캔버스는 그래픽이 잘 동작하고 성능이 저하되지 않도록 엘리먼트 사용을 최적화할 수 있는 방법이다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch4\u003e성능 비교\u003c/h4\u003e\n\u003cp\u003e1px dom 25만개를 그렸을때 걸리는 시간에 대한 \u003ca href=\"https://medium.com/@idchoi2/javascript-%EB%8F%84%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0-html-vs-svg-vs-canvas-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-9e1ce2396fcd\"\u003eidchoi2\u003c/a\u003e\n님의 글을 읽어보고 나니.. 렌더링 시간이 확연히 차이가 있었다.\u003c/p\u003e\n\u003cp\u003e|          | 렌더링 시간          | 메모리 사용량 |\n| -------- | -------------------- | ------------- |\n| HTML DOM | 4356.28ms (3~4초)    | 796.3M        |\n| SVG      | 7799.06ms (6~7초)    | 1.7G          |\n| Canvas   | 430.71ms (0.3~0.4초) | 217.6M        |\u003c/p\u003e\n\u003chr\u003e\n\u003ch4\u003e결론\u003c/h4\u003e\n\u003cp\u003e그래서 렌더링 속도가 빠른 캔버스로 그려봤다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst draw = (curr) =\u003e {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const tot = 1000;\n  const percent = Math.floor((curr / tot) * 100);\n  const height = 25;\n\n  if (this.width === null) {\n    this.width = document.querySelectorAll('th')[2].clientWidth;\n  }\n  const width = this.width * (percent / 100);\n\n  canvas.width = width + 50;\n  canvas.height = height;\n  ctx.fillStyle = 'green';\n  ctx.font = '10px Aria';\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = 'white';\n\n  // 퍼센트값\n  ctx.fillText(`${percent}%`, 8, height - 10);\n  ctx.textAlign = 'right';\n\n  // 실제값\n  ctx.fillText(curr, width + 30, height - 10);\n  ctx.textAlign = 'left';\n\n  return canvas;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e결과\u003c/strong\u003e\n\u003cimg src=\"/img/post-2019-06-10-1.png\" alt=\"canvas\"\u003e{:width=\"100%\" height=\"50%\"}\u003c/p\u003e\n","category":"HTML_CSS"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"canvas"},"buildId":"n1F0CVZ8gd7T38i1_wAcz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>