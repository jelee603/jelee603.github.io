<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="viewport-fit=cover"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/6eca03e35c9c9eae.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6eca03e35c9c9eae.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-63157d71ad419e09.js" defer=""></script><script src="/_next/static/chunks/main-2f1c90f15011e7a4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-220f73948b70f663.js" defer=""></script><script src="/_next/static/chunks/23-1e1b6cd9f6a2e676.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-eb045ea4ab526c15.js" defer=""></script><script src="/_next/static/GooIiPSF99HtY3NMbDDyv/_buildManifest.js" defer=""></script><script src="/_next/static/GooIiPSF99HtY3NMbDDyv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="sc-986ff7fc-0 imLcot"><nav class="sc-986ff7fc-1 eEnMlM"><div class="sc-986ff7fc-2 iVcRKG"><a href="/">Home</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/React/react-condition">React</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/Vue/vuejs">Vue</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/JavaScript/es6">JavaScript</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/TypeScript/typescript">TypeScript</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/HTML_CSS/browser-operation">HTML/CSS</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/ToyProject">Toy Project</a></div><a href="/profile"><div class="sc-986ff7fc-3 UcNoa"></div></a></nav></header><section class="sc-53569208-0 qXGRu"><h1 class="sc-53569208-1 kqSQaB">Javascript Event 이야기</h1><h6>2019-08-22</h6><article class="sc-53569208-2 lhbsva"><h4>이벤트 리스너를 등록해서 사용할 때, <code>removeEventListener</code> 가 필요할까?</h4>
<p>전체 화면에서 히든 페이지가 필요해져서 window 객체에 keyup 이벤트를 등록하는 방법으로 문제를 해결한 경우가 있는데,
이 이벤트를 제거해줄 필요가 있는지에 대해서 고민이 되었다.</p>
<h4>이벤트 리스너의 this 는 어떻게 인지할까?</h4>
<p>this 를 잘 바꿔줄 때, 필요한 메서드가 call, apply, bind 이다.</p>
<p><a href="https://mygumi.tistory.com/332">mygumi</a>님과 <a href="https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd">zerocho</a>님의 글이 도움이 되었다.
call, apply 는 함수를 호출하는 거고, 인자를 넘기고 반환값을 돌려받는 창구가 있을때 주로 사용한다.
call 은 파라미터 중 첫번째 인자를, 내부에서 사용할 this 로 만들어준다.
apply 도 마찬가지이고, 대신에 파라미터를 배열로 넘긴다.
bind 는 this 만 바꾸고 호출하지는 않는다. 원본 함수를 호출하도록 하드 코딩된 새로운 함수를 생성한다.
이건 다른말로 콜백 형식을 만들어줄 수 있다.</p>
<pre><code>function Person() {
  this.name = this.name || 'default';
  this.authority = 'guest';
  return this.name + ' is ' + this.authority;
}

// call 은 새 함수로 만들어서 호출한다.
Person.call({ name: 'bill' }); // "bill is guest"

// 1. bind 는 this을 교체해준다.
const userInfo = Person.bind({ name: 'test' }); // undefined
// 2. 함수를 호출한다.
userInfo(); // "test is guest"

// call 은 새 함수로 만들어서 호출한다.
const userInfo3 = Person.call({ name: 'test3' }); // undefined
userInfo3; // "test3 is guest"
</code></pre>
<h4>클로저는 어떻게 사용할까?</h4>
<p>생명주기가 끝난 함수의 변수를 외부 함수에서 호출하는 걸 일컬어 클로저라 한다.
클래스로 만든 내부 이벤트를 외부에서 제어를 하려고 고민을 하다가 클로저를 응용할 수 있겠다 싶었다.
위에 bind 는 스코프만 바뀌는 거고, call 은 원본 함수를 호출할 수 있는 새 함수로 만들어준다.</p>
<pre><code>function funcA(value1, value2) {
  console.log(`value: ${value1} ${value2}`);
}

funcB = () => funcA.call(this, 2, 3);
funcB(); // value: 2 3
</code></pre>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Javascript Event 이야기","slug":"event","date":"2019-08-22","content":"\u003ch4\u003e이벤트 리스너를 등록해서 사용할 때, \u003ccode\u003eremoveEventListener\u003c/code\u003e 가 필요할까?\u003c/h4\u003e\n\u003cp\u003e전체 화면에서 히든 페이지가 필요해져서 window 객체에 keyup 이벤트를 등록하는 방법으로 문제를 해결한 경우가 있는데,\n이 이벤트를 제거해줄 필요가 있는지에 대해서 고민이 되었다.\u003c/p\u003e\n\u003ch4\u003e이벤트 리스너의 this 는 어떻게 인지할까?\u003c/h4\u003e\n\u003cp\u003ethis 를 잘 바꿔줄 때, 필요한 메서드가 call, apply, bind 이다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://mygumi.tistory.com/332\"\u003emygumi\u003c/a\u003e님과 \u003ca href=\"https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd\"\u003ezerocho\u003c/a\u003e님의 글이 도움이 되었다.\ncall, apply 는 함수를 호출하는 거고, 인자를 넘기고 반환값을 돌려받는 창구가 있을때 주로 사용한다.\ncall 은 파라미터 중 첫번째 인자를, 내부에서 사용할 this 로 만들어준다.\napply 도 마찬가지이고, 대신에 파라미터를 배열로 넘긴다.\nbind 는 this 만 바꾸고 호출하지는 않는다. 원본 함수를 호출하도록 하드 코딩된 새로운 함수를 생성한다.\n이건 다른말로 콜백 형식을 만들어줄 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction Person() {\n  this.name = this.name || 'default';\n  this.authority = 'guest';\n  return this.name + ' is ' + this.authority;\n}\n\n// call 은 새 함수로 만들어서 호출한다.\nPerson.call({ name: 'bill' }); // \"bill is guest\"\n\n// 1. bind 는 this을 교체해준다.\nconst userInfo = Person.bind({ name: 'test' }); // undefined\n// 2. 함수를 호출한다.\nuserInfo(); // \"test is guest\"\n\n// call 은 새 함수로 만들어서 호출한다.\nconst userInfo3 = Person.call({ name: 'test3' }); // undefined\nuserInfo3; // \"test3 is guest\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e클로저는 어떻게 사용할까?\u003c/h4\u003e\n\u003cp\u003e생명주기가 끝난 함수의 변수를 외부 함수에서 호출하는 걸 일컬어 클로저라 한다.\n클래스로 만든 내부 이벤트를 외부에서 제어를 하려고 고민을 하다가 클로저를 응용할 수 있겠다 싶었다.\n위에 bind 는 스코프만 바뀌는 거고, call 은 원본 함수를 호출할 수 있는 새 함수로 만들어준다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction funcA(value1, value2) {\n  console.log(`value: ${value1} ${value2}`);\n}\n\nfuncB = () =\u003e funcA.call(this, 2, 3);\nfuncB(); // value: 2 3\n\u003c/code\u003e\u003c/pre\u003e\n","category":"JavaScript"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"event"},"buildId":"GooIiPSF99HtY3NMbDDyv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>