<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="viewport-fit=cover"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/6eca03e35c9c9eae.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6eca03e35c9c9eae.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-63157d71ad419e09.js" defer=""></script><script src="/_next/static/chunks/main-63b5e73f15fce3bf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-220f73948b70f663.js" defer=""></script><script src="/_next/static/chunks/23-1e1b6cd9f6a2e676.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-7d709a5d09fee3dd.js" defer=""></script><script src="/_next/static/XabKDqyn7GZ-CmiiEg_37/_buildManifest.js" defer=""></script><script src="/_next/static/XabKDqyn7GZ-CmiiEg_37/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="sc-45b68ef7-0 ieAueO"><nav class="sc-45b68ef7-1 cDSFRs"><div class="sc-45b68ef7-2 iKGhce"><a href="/">Home</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/React/react-condition">React</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/Vue/vuejs">Vue</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/JavaScript/es6">JavaScript</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/TypeScript/typescript">TypeScript</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/HTML_CSS/browser-operation">HTML/CSS</a></div><div class="sc-45b68ef7-2 iKGhce"><a href="/ToyProject">Toy Project</a></div><a href="/profile"><div class="sc-45b68ef7-3 TXhNy"></div></a></nav></header><section class="sc-53569208-0 qXGRu"><h1 class="sc-53569208-1 kqSQaB">Javascript 디자인패턴 이야기</h1><h6>2019-09-11</h6><article class="sc-53569208-2 lhbsva"><h2>클래스란 (클래스/상속 디자인 패턴)</h2>
<p>클래스화란 데이터와 작동을 함께 잘 감싸서 캡슐화하는 것이 올바른 설계이다.
데이터에 적용 가능한 작동들을 메서드로 설계해야한다.
클래스에서는 어떤 작동이 담긴 메서드의 이름을 부모와 자식 클래스 모두 똑같이 공유하여 자식 클래스가 부모 클래스를 오바라이드하라고 권장한다.
그러나 자바스크립트에서는 이렇게 하면 불안정한 결과를 불러온다.</p>
<p>나는 대부분 절차적 프로그래밍을 해왔다는 걸 알게 되었다. 상위 추상화 없이 단순히 다른 함수를 호출해서 사용하는 방법만 사용해왔고,
클래스의 경우는 라이브러리를 통해서만 사용했었다. 그래서 편리함은 알지만, 다뤄보지 않은 영역이라 이번 기회에 다시 정리하고자 한다.</p>
<p>클래스는 복사 과정을 거쳐 객체 형태로 인스턴스화 한다.
인스턴스는 생성자가 해주는데 이 생성자는 미리 정보에 대한 변수를 초기화해준다.
항상 new 키워드를 앞에 붙여 생성자를 호출한다.</p>
<pre><code>class Button {}
var btn1 = new Button();
</code></pre>
<p>오버라이드하기 전의 원본 메서드와 오버라이드 메서드가 다를 수도 있는데 이를 다형성(오버라이드)이라 한다.
inherits/super 라는 키워드로 사용하며, 부모/조상 중 어떤 메서드를 호출할지 결정하는 것도 다형성의 기법이다.</p>
<blockquote>
<p>자바스크립트엔 클래스란 개념 자체가 없고 오직 객체만 있다. 그래서 위와 같은 동작들은 자동으로 일어나지 않는다. 
인스턴스화 해도 자동으로 복사가 되지않기 때문에 믹스인으로 클래스 복사기능을 흉내내었다.
이런 기능을 여러 라이브러리에서는 <code>extends()</code> 라 하고, 프로퍼티를 복사를 할 수 있게 제공된다.
믹스인 과정을 초콜릿 조각을 본인이 원하는 쿠키 반죽에 섞어 넣는 것에 비유한다. (이 말이 가장 기억에 남을거 같다)
&#x3C;You Don't Know JS: this와 객체 프로토타입, 비동기와 성능 - 카일 심슨></p>
</blockquote>
<p>이렇게 일일히 복사(믹스인) 하더라도 다른 클래스 지향처럼 100%(인스턴스) 복사는 어렵다.</p>
<h2>프로토타입이란 (프로토타입 디자인 패턴)</h2>
<p>객체를 다른 객체에 연결한다. 수평적인 상태에서 위임이 되는 연결이다.
오버라이드 하기 딱 좋은 메서드 명칭보다는 각 객체의 작동방식을 설명하는 서술적인 명칭이 필요하다.
모든 레퍼런스가 확실히 존재한다면 양방향 위임은 가능하긴 하지만 무한 루프에 빠질 수 있다.</p>
<pre><code>var btn1 = Object.create(Button);
btn1.setup();
</code></pre>
<p>어떤 함수가 call(), apply(), bind() 메서드에 접근할 수 있는 건 함수 자신도 객체고 함수 객체 역시 <code>Function.prototype</code>에
[[Prototype]]이 연결되어 위임 가능한 메서드가 있어 가능한 것이다.
<a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">infoscis</a>님 블로그에 예제가 잘 나와있다.</p>
<pre><code>// ES6 [[Prototype]] 에 저장된 값을 변경한다.
Object.setPrototyupeOf();
</code></pre>
<h2>디자인 패턴이란</h2>
<blockquote>
<p>반복적으로 발생하는 문제와 그 문제의 해법으로 정의된다.
패턴은 유사한 상황에서 반복적으로 적용할 수 있는 책임-주도 설계의 결과물이다.  그리고 그 방법이 왜 더 효과적인지에 대한 이유를 설명한다. 
&#x3C;객체 지향의 사실과 오해 - 조영호></p>
</blockquote>
<h3>1. Composite 패턴</h3>
<p>동일한 인터페이스를 제공해야한다는 제약하에 역할, 책임, 협력을 제공하는 설계 방법이다.</p>
<p>Leaf 의 역할은 공용 인터페이스의 협력
Client 는 Component 에게 메시지를 요청하는 역할
Component 의 역할은 다른 컴포넌트를 추가, 제거, 포함된 컴포넌트를 반환하는 역할</p>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Javascript 디자인패턴 이야기","slug":"pattern","date":"2019-09-11","content":"\u003ch2\u003e클래스란 (클래스/상속 디자인 패턴)\u003c/h2\u003e\n\u003cp\u003e클래스화란 데이터와 작동을 함께 잘 감싸서 캡슐화하는 것이 올바른 설계이다.\n데이터에 적용 가능한 작동들을 메서드로 설계해야한다.\n클래스에서는 어떤 작동이 담긴 메서드의 이름을 부모와 자식 클래스 모두 똑같이 공유하여 자식 클래스가 부모 클래스를 오바라이드하라고 권장한다.\n그러나 자바스크립트에서는 이렇게 하면 불안정한 결과를 불러온다.\u003c/p\u003e\n\u003cp\u003e나는 대부분 절차적 프로그래밍을 해왔다는 걸 알게 되었다. 상위 추상화 없이 단순히 다른 함수를 호출해서 사용하는 방법만 사용해왔고,\n클래스의 경우는 라이브러리를 통해서만 사용했었다. 그래서 편리함은 알지만, 다뤄보지 않은 영역이라 이번 기회에 다시 정리하고자 한다.\u003c/p\u003e\n\u003cp\u003e클래스는 복사 과정을 거쳐 객체 형태로 인스턴스화 한다.\n인스턴스는 생성자가 해주는데 이 생성자는 미리 정보에 대한 변수를 초기화해준다.\n항상 new 키워드를 앞에 붙여 생성자를 호출한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Button {}\nvar btn1 = new Button();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e오버라이드하기 전의 원본 메서드와 오버라이드 메서드가 다를 수도 있는데 이를 다형성(오버라이드)이라 한다.\ninherits/super 라는 키워드로 사용하며, 부모/조상 중 어떤 메서드를 호출할지 결정하는 것도 다형성의 기법이다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e자바스크립트엔 클래스란 개념 자체가 없고 오직 객체만 있다. 그래서 위와 같은 동작들은 자동으로 일어나지 않는다. \n인스턴스화 해도 자동으로 복사가 되지않기 때문에 믹스인으로 클래스 복사기능을 흉내내었다.\n이런 기능을 여러 라이브러리에서는 \u003ccode\u003eextends()\u003c/code\u003e 라 하고, 프로퍼티를 복사를 할 수 있게 제공된다.\n믹스인 과정을 초콜릿 조각을 본인이 원하는 쿠키 반죽에 섞어 넣는 것에 비유한다. (이 말이 가장 기억에 남을거 같다)\n\u0026#x3C;You Don't Know JS: this와 객체 프로토타입, 비동기와 성능 - 카일 심슨\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이렇게 일일히 복사(믹스인) 하더라도 다른 클래스 지향처럼 100%(인스턴스) 복사는 어렵다.\u003c/p\u003e\n\u003ch2\u003e프로토타입이란 (프로토타입 디자인 패턴)\u003c/h2\u003e\n\u003cp\u003e객체를 다른 객체에 연결한다. 수평적인 상태에서 위임이 되는 연결이다.\n오버라이드 하기 딱 좋은 메서드 명칭보다는 각 객체의 작동방식을 설명하는 서술적인 명칭이 필요하다.\n모든 레퍼런스가 확실히 존재한다면 양방향 위임은 가능하긴 하지만 무한 루프에 빠질 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar btn1 = Object.create(Button);\nbtn1.setup();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e어떤 함수가 call(), apply(), bind() 메서드에 접근할 수 있는 건 함수 자신도 객체고 함수 객체 역시 \u003ccode\u003eFunction.prototype\u003c/code\u003e에\n[[Prototype]]이 연결되어 위임 가능한 메서드가 있어 가능한 것이다.\n\u003ca href=\"https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/\"\u003einfoscis\u003c/a\u003e님 블로그에 예제가 잘 나와있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// ES6 [[Prototype]] 에 저장된 값을 변경한다.\nObject.setPrototyupeOf();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e디자인 패턴이란\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e반복적으로 발생하는 문제와 그 문제의 해법으로 정의된다.\n패턴은 유사한 상황에서 반복적으로 적용할 수 있는 책임-주도 설계의 결과물이다.  그리고 그 방법이 왜 더 효과적인지에 대한 이유를 설명한다. \n\u0026#x3C;객체 지향의 사실과 오해 - 조영호\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e1. Composite 패턴\u003c/h3\u003e\n\u003cp\u003e동일한 인터페이스를 제공해야한다는 제약하에 역할, 책임, 협력을 제공하는 설계 방법이다.\u003c/p\u003e\n\u003cp\u003eLeaf 의 역할은 공용 인터페이스의 협력\nClient 는 Component 에게 메시지를 요청하는 역할\nComponent 의 역할은 다른 컴포넌트를 추가, 제거, 포함된 컴포넌트를 반환하는 역할\u003c/p\u003e\n","category":"JavaScript"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"pattern"},"buildId":"XabKDqyn7GZ-CmiiEg_37","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>