{"pageProps":{"post":{"title":"Vue 이야기","slug":"vuejs","date":"2019-08-14","content":"<p>MVC 패턴이 도입되면서 Controller 에서 데이터 작업들에 대한 역할 분담을 해왔고,\nVue 는 MVVM 패턴으로 중간에 ViewModel 객체를 두고 데이터에 대한 의존성을 분리하기 위해 사용한 패턴이다.\n같은 데이터인데 몇가지 조합해서 가공이 필요한 경우에 View Model 부분에서 수정을 하게끔 정해져있다.\n(Dom listener, Directives, Data Binding 등등..)</p>\n<ul>\n<li>렌더링은 React 랑 유사하고 Virtual DOM 을 사용해서 가볍고 빠름.</li>\n<li>양방향 데이터 바인딩 (Vue 인스턴스와 Template) 이 모두 데이터에 접근할 수 있음. (v-model)</li>\n<li>뷰는 인스턴스가 생성되면 데이터 바인딩을 할 동안 루트요소의 모든 자식 노드를 탐색하면서 데이터 변경에 반응함.</li>\n<li>뷰는 DOM 을 비동기적으로 업데이트하고 <code>Vue.nextTick(callback)</code> 을 사용하면 업데이트된 이후를 보장할 수 있음.</li>\n</ul>\n<p>그런데 이러한 계층 구조는 데이터 뿐만 아니라. 컴포넌트 상에서도 접목된다.</p>\n<p>그 이후로 컴포넌트라는 개념이 자리잡았고, 비지니스 로직과 View 로직이 분리되면서 HTML 작업만 따로 작업을 할 수도 있게 되었다.\n그러면서 공통적으로 사용할 UI 인 경우엔 컴포넌트로 분리하고 필요하면 데이터만 변경해서 사용할 수 있게 만들어 놓게 되었다.</p>\n<p>그리고 이렇게 발전한 사용법으로 Vue 를 접했을 땐, 자식 컴포넌트는 이미 부모 레벨의 정보를 들고 있을 수 있게 되었단걸 알게 되었다.</p>\n<h4>부모에서 자식 계층으로 정보를 전달하는 방법은?</h4>\n<p>공통 컴포넌트라고 하면 보통은 제일 마지막 자식 계층일 경우가 많다.\n그래서 이 계층에서는 mounted 에서 부모의 clientHeight 를 구해올 수 있다.</p>\n<pre><code>this.$parent;\nthis.$el.parent;\n</code></pre>\n<h4>Vue Component 에 타입스크립트 해서 적용해본 사례는?</h4>\n<p>SFC(Single File Component) 는 Vue가 권장하는 Vue 컴포넌트 전용 파일 포맷이다. 한 파일 안에 템플릿과 자바스크립트 그리고 CSS까지 정의한다.\n개발자가 클래스를 정의하기보다는 클래스를 만들 수 있는 옵션을 정의하는 형태로 개발한다.\n엄격한 타입의 언어를 다루던 개발자들이 자바스크립트를 다뤄야할때 완충 역할로 타입스크립트를 사용했고,\n타입은 어플리케이션 설계 전체에 영향을 주는 것이라 필요하게 되었다라고 말하는 <a href=\"https://ui.toast.com/weekly-pick/ko_20190327/\">shiren</a>님의 글을 보게 되었다는데 아마\n상당한 시행착오를 겪은 걸 보고, 우리도 Vue3로 전환하면 사용하게 될 거 같다는 생각이 든다.</p>\n<h3>Vue Test Util</h3>\n<p><a href=\"https://joshua1988.github.io/vue-camp/testing/vue-test-util.html#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%84%A4%EC%B9%98\">joshua</a> 님 블로그에 보면, vue-cli 로 자동으로 설치가 된다하였지만, 기존에 만들었던 프로젝트는 vue-cli(2.x) 이라 모듈 설치방법으로 진행해봤다.\njest 라이브러리 설치</p>\n<pre><code>npm install jest @vue/test-utils vue-jest babel-jest --save-dev\n</code></pre>\n<h4>ESLint 적용하기</h4>\n<p>standard 를 사용해보고 싶어서 적용했고, indent만 4칸만 지정했다.\n<code>npm run eslint --fix</code> 로 사용이 가능하다.</p>\n<pre><code>// 기본설치\nnpm install -D --save eslint eslint=plugin-vue\n\n// 추가사항\nnpm install -D --save eslint-plugin-import\nnpm install -D --save eslint-plugin-node\nnpm install -D --save eslint-plugin-promise\nnpm install -D --save eslint-plugin-standard\n</code></pre>\n<p>indent 만 설정한 기본 파일로 세팅했다.</p>\n<pre><code>// .eslint.js\n\nmodule.exports = {\n  root: true,\n  extends: ['standard', 'plugin:vue/recommended'],\n  rules: {\n    indent: ['error', 4],\n  },\n};\n</code></pre>\n<h4>Child 의 이벤트를 전달하는 방법 (EventBus)</h4>\n<pre><code>// Child.vue\n&#x3C;template>\n    &#x3C;div>\n        &#x3C;input @input=\"event => this.$emit('inputChange', event)\" />\n    &#x3C;/div>\n&#x3C;/template>\n\n// Parent.vue\n&#x3C;template>\n    &#x3C;div>\n        &#x3C;Child v-on:inputChange=\"handleChange\" />\n        &#x3C;p>Value: {{value}}&#x3C;/p>\n    &#x3C;/div>\n&#x3C;/template>\n&#x3C;script>\n    import Child from './Child.vue'\n\n    export default {\n        data() {\n            return {\n                value: '',\n            };\n        },\n        components: {\n            Child,\n        },\n        methods: {\n            handleChange(event) {\n                const { value } = event.target;\n                this.value = value;\n            }\n        }\n    }\n&#x3C;/script>\n</code></pre>\n<p>v-on:inputChange 는 심플하게 @inputChange 이렇게 사용할 수 있고,\n@input 입력이 되면, Parent 의 handleChange 메서드에 값이 전달된다.\n이걸 내 방법으로 표현하면, <code>this.$emit('inputChange', event)</code> 이벤트 명을 정해주면 hook 이 걸려서\n동작한 값을 해당 이벤트 명에 전달해줄 수 있다는 의미가 될 수 있겠다.</p>\n<p>출처: https://stackoverflow.com/questions/40915436/vuejs-update-parent-data-from-child-component</p>\n","category":"Vue"}},"__N_SSG":true}