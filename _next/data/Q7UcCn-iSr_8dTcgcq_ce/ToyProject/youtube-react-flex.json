{"pageProps":{"post":{"title":"컨퍼런스 정리 - 왜 나는 React를 사랑하는가 (1)","slug":"youtube-react-flex","date":"2023.11.09","content":"<p>YouTube URL: <a href=\"https://www.youtube.com/watch?v=dJAEWhR83Ug\">https://www.youtube.com/watch?v=dJAEWhR83Ug</a> - FECONF 2021</p>\n<h2>목차</h2>\n<ul>\n<li>클리어한 멘탈 모델, 작고 단단한 코어<ul>\n<li>한번 배우면 동일한 언어로 여러곳에 사용</li>\n</ul>\n</li>\n<li>꾸준히 성장하는 거대한 커뮤니티</li>\n<li>도전적인 과제, 우아한 해결책<ul>\n<li>Fiber, Hooks, Suspense 개념</li>\n<li>&#39;와&#39;, 어떻게 이런 생각을 했지?</li>\n</ul>\n</li>\n</ul>\n<p>문제를 어떻게 풀어내려 했다는 점도 그렇고 문제를 풀어내는 것을 보면 와 멋지다라는 생각이 들었다. </p>\n<p>리액트의 장점을 한 언어로 바라보게 된다면, 어떨까 싶었다. </p>\n<p>생각도 해보고 자료도 조사하다보니 갈수록 말이 되었다. </p>\n<p>발표의 시각은 React= 프로그래밍 언어?라는 생각이다. </p>\n<p>공식 문서에 리액트는 자바스립트 라이브러리이다. 리액트를 프로그래밍 언어로 바라보면 어떨까?</p>\n<p>큰 그림에서의 유사점을 찾기 위한 시도, 세세히 따지면 모든 면에서 엄밀한 내용은 아니다. </p>\n<p>다음과 같이 정리해볼 수 있다.</p>\n<h2>클리어한 멘탈 모델, 작고 단단한 코어</h2>\n<ol>\n<li>React = 프로그래밍 언어?</li>\n</ol>\n<ul>\n<li><p>리액트와 프로그래밍 언어: 값\nUI 프로그래밍 언어에서의 역할, 화면에 그려지는 특정 UI 조각에 대응하는 무언가.\njsx 문법으로도 엘리먼트를 작성할 수 있고,\n리액트의 createElement API 를 사용할 수도 있다. </p>\n</li>\n<li><p>리액트와 프로그래밍 언어: 함수</p>\n</li>\n</ul>\n<p>특정 동작을 수행하는 부분을 별도로 나눠서 함수로 정의할 수 있다. 함수는 입력값을 받을 수도 있고, 동작을 수행하고 값을 반환한다. 그 과정에서 다른 함수를 부르기도 한다. \n리액트의 함수는 컴포넌트이다. props라는 입력을 받아서 리액트의 값인 엘리먼트를 반환한다. \n함수가 다른 함수를 호출하는 것처럼 리액트 역시 다른 컴포넌트를 호출한다. </p>\n<ul>\n<li>리액트와 프로그래밍 언어: 예외 처리</li>\n</ul>\n<p>예외처리에 대한 대응할 수단이 필요하다. 특정 코드르 블럭에서 예외가 발생하려고 할 때, try문을 감싼 뒤에 catch 문에서 예외를 잡아 처리할 수 있다. 리액트는 함수 호출 중 렌더링 중에 발생한 오류를 처리하기 위한 에러 바운더리라는 API 를 제공한다. </p>\n<pre class = \"line-numbers\"><code class = \"language-js\"><span class=\"token operator\">&lt;</span>Try catch<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>Fallback error<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>e<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>Widget <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Try<span class=\"token operator\">></span></code></pre><ul>\n<li>리액트와 프로그래밍 언어: 타입 체크</li>\n</ul>\n<p>정적 타입을 제공하는 언어라면 특정 종류의 예외가 실제 사용자에게 영향을 미치기 전에 잡아줄 수 있는 수단을 제공\n리액트도 아주 원시적이지만 prop types라는 패키지로 함수 입력 즉, 컴포넌트의 props에 대한 타입체크까지 제공한다. </p>\n<ol start=\"2\">\n<li>소스 코드, 엔진, 어셈블리</li>\n</ol>\n<p>소스코드는 엔진을 통해서 해석및 실행되는 과정을 거친다. \n가장 유명한 Node.js, 크롬 등에 내장된 V8엔진이 있다. </p>\n<p>cpu가 해석할 수 있는 언어로 변환해서 기계에게 일을 시키게 된다. 이 기계가 이해할 수 있는 명령의 집합을 어셈블리어라고 부른다. 우리는 소스코드가 엔진이 해석할 수 있는 형태인지, 즉 올바른 문법으로 작성된 자바스크립트 코드인지만 신경을 쓰면 아키텍쳐와 무관하게 잘 동작하는 프로그램을 만들 수 있다. </p>\n<pre class = \"line-numbers\"><code class = \"language-js\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">\"react-dom\"</span></code></pre><p>리액트 돔과 리액트를 왜 나눌까?라는 궁금증이 있었는데 알고보니 되게 좋은 이유가 있었다. </p>\n<p>과거 리액트 코어팀 매니저 - Sophie Alpert 의 Building a Custom React Renderer(2019) 발표를 예시.</p>\n<p>리액트라는 모든 문법적 요소가 Renderer와 무관하게 다루는 내용을 다룸</p>\n<p>reconciler 라는 부분은 리액트 코드를 해석하고 실행하는 역할을 한다. 실행하고 해석하는 엔진의 역할을 맡았다고 볼 수 있다. 엔진이 소통하는 기계, 근본적으로 환경별로 공유할 수 없는 코드가 존재하는데 네이티브에서 html 을 그리기 위한 코드를 사용할 수 없듯이 리액트의 UI트리가 실제로 그려지는 고유한 환경이 프로그램이 실행되는 기계에 해당한다. </p>\n<p>UI가 그려지는 환경이 어디냐에 따라 호스트 환경이 리액트가 실행되는 CPU 또는 기계에 해당한다.\n호스트 환경 API가 리액트의 어셈블리가 된다. </p>\n<p>DOM API 호출이 될 수 있고, JSON 환경에서의 Array의 push프로토타입 메서드가 될 수도 있고, 그 외에도 환경에 따라 달라지는 임의의 방식으로 번역될 수 있다. </p>\n<p>커스텀 환경만 존재한다면, 임의의 리액트 앱을 그릴 수 있다. </p>\n<p>리액트가 자바스크립트의 문법을 취하고 있지만, 동시에 UI 프로그래밍 언어로 바라볼 수 있다는 게 어떤 의미인지 어느정도 전달, 더 많은 것은 생각해보는 것도 좋을 거 같다. </p>\n<ol start=\"3\">\n<li>명확한 문제 및 목표 정의</li>\n</ol>\n<p>리액트가 웹 UI 라이브러리였다면? 웹에서 쓰일거니깐 코어 라우터나, renderDOM 을 react 라이브러리에서 임포트해서 사용할 수 있지 않았을까. 개인적으로 해석이 가능한 부분을 설명한다.</p>\n<blockquote>\n<p>Virtual DOM은 너무 느려!</p>\n</blockquote>\n<p>다양한 라이브러리에서 비판하는 점 중에 하나가 DOM을 직접 조작하면 되는데 왜 별도의 UI트리를 관리해서 코드 베이스의 복잡도를 올리고 오버헤드를 감수하는가? 그렇기 때문에 너무 느린거 아닌가하는 비판이 있다. 웹 환경만을 생각하면 올바른 비판일 수 있다. 리액트의 맥락에서는 핀트가 벗어난 게 아닐까라고 개인적으로 생각한다. </p>\n<p>코어로직이 웹 환경과 직접적으로 붙지 않는거 자체가 리액트의 의도적인 결정이기 때문.</p>\n<blockquote>\n<p>Just JavaScript</p>\n</blockquote>\n<p>hook이나 서스펜스같은 복잡한 개념이 잔뜩이지만, 자바스크립트로 작성한 소스코드는 다양한 환경에서 실행될 수도 있다. 그 환경은 브라우저가 아닐 수도 있고 Node.js 에서 돌아가는 서버환경이 아닐 수도 있다. 리액트는 자바스크립트가 쓰이는 모든 환경에서 UI를 만들기 위한 수단으로 쓰일 수 있다.</p>\n<p>언어로 발전시키지 않았던 이유가, 문제와 목표 정의 단계에서의 작은 차이가 지금까지 발전해온 방향에 영향을 미쳤을 것이라고 생각한다.</p>\n<h2>꾸준히 성장하는 거대한 커뮤니티</h2>\n<p>리액트를 사용하는 사람들, 리액트로 제품을 만드는 사람들, 리액트에 관련된 블로그 글과 유튜브 영상, 스택오버플로우 질문 답변 등등 점점 더 새로운 가치가 만들어지고 있다는 점이 있다. </p>\n<p>러스트 프로그래밍 언어 코어팀 - Steve Klabnik 의 문구를 인용.</p>\n<p>가치가 비용보다 큰 물건들 중에서도 전체 비용의 합이 예산을 초과하지 않는 범위 내에서 소비계획을 세우게 됩니다.</p>\n<p>기술 선택에도 마찬가지로 비용이든다. 리액트는 지금도 자바스크립트라는 언어의 다양한 제약을 라이브러리 단에서 워크어라운드하고 있는데 Elm, ReScript 는 상대적으로 그런 제약을 받고 있지 않다.</p>\n<p>아예 새로운 언어를 만들지 않고, 라이브러리의 형태를 취하는게 지금의 리액트의 성공에 큰 기여를 한 것이라고 생각한다.\n리액트가 언어였다면, </p>\n<ul>\n<li>부족한 리소스 텅빈 스택오버플로우</li>\n<li>적은 유저풀</li>\n<li>새로운 패키지 매니저</li>\n</ul>\n<hr>\n<ul>\n<li>jsx </li>\n<li>선언적 렌더링</li>\n<li>컴포넌트 기반 개발</li>\n</ul>\n<p>라는 문제들을 부딪쳤을테지만, 자바스크립트를 선택함으로 문법적 요소와 동작에서의 새로운 멘탈 모델에만 집중할 수 있었다. 아주 좋은 접근이었다고 생각한다.</p>\n<h2>도전적인 과제, 우아한 해결책</h2>\n<p>Dan abramov가 리액트 코어팀에서의 시간을 회고하는 스레드에서 발췌 \n모든 문제를 어떻게 환원가능한지 찾는 행위가 중요성으로 이어지는 것 같다.</p>\n<p>새로운 문제 A가 생겼는데, 이미 답안지를 알고 있는 B라는 문제의 해결책을 A라는 문제에 가져다 쓸 수 있다. \n리액트에서의 환원의 사례는?</p>\n<blockquote>\n<p>컴포넌트가 트리 저 위쪽에 정의된 무언가의 값을 꺼내올 수단이 필요하다. -&gt; 참조 시점에 둘러싼 환경을 기준으로 평가되는 변수니까 유사하니까, 프로그래밍 언어의 동적 스코핑과 비슷하다? Context</p>\n</blockquote>\n<blockquote>\n<p>자바스크립트 싱글 스레드 환경에서 느린 컴포넌트가 우선순위가 높은 업데이트를 막아 생기는 반응성 저해(사용자의 인풋에 대한 반응, 애니메이션 등)를 방지할 수단이 필요하다. -&gt; 우선순위가 다른 작업들이 동시에 잘 실행되는 것처럼 보이게 만드는 일? 운영체제의 스케쥴링과 비슷하다? Fiber (비선점형 스케쥴링에서 가벼울 실행 스레드를 나타내는 용어)</p>\n</blockquote>\n<blockquote>\n<p>함수와 라이프사이클을 클래스 컴포넌트만 사용하지 말고, 함수 컴포넌트의 제약을 제거하고 상태 로직의 응집성,재사용성을 개선하고 싶다. -&gt; 특정 효과(상태라든지 라이프사이클 이펙트)를 처리하는 방식을 리액트에게 위임할 수단을 찾는다. 대수적 효과랑 비슷하다? Hooks</p>\n</blockquote>\n<p>비동기로 불러와야하는 리소스를 선적으로 정의하고 싶다. -&gt; 특정 효과(비동기 호출)처리를 리액트에게 위임할 수단을 찾는다. 대수적 효과랑 비슷하다? Suspense</p>\n<p>리액트의 행보는 이런 문제를 이렇게 풀 수 있다는 점이 모두 환원들을 찾아서 해결할 수 있었다. </p>\n<p>이런 자각들이 알게 모르게 문제를 해결할 수 있게 된다.</p>\n<p>플레스팀에서의 환원 예시.</p>\n<p>리모트 레이어 개편 작업, axios 호출 등이 다양한 형태로 동일한 역할을 하는 코드가 작성되고 있는 문제가 있었다. \n리모트 레이어는 (서버 API 모델 정의, 엔드포인트 호출, 데이터 관리 등) 영역 전반을 의미한다. </p>\n<p>리모트 데이터를 가져오는 과정에서 필요한 재검증, 로딩상태 처리, 에러 처리 등의 다양한 부분을 자동화해주는 SWR 라이브러리를 사용하고 있었다. 서로 달라야하는 키나 같아야하는 키가 다른 키를 사용하게 되면 크고 작은 문제의 원인이 된다. 그 전에는 리모트 키를 관리하고 유니크하게 관리하는 책임이 개발자에게 맡겨진 영역이었다. </p>\n<p>리모트 데이터를 가져오는 방법에 대한 수많은 패턴의 코드를 개선하고 싶어졌다. </p>\n<blockquote>\n<p>문제 정의 </p>\n<ul>\n<li>사용처 별로 제각각이다. </li>\n<li>리모트 리소스 정의 방식</li>\n<li>SWR 생성 방식</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>목표?</p>\n<ul>\n<li>리모트 레이어 사용</li>\n<li>컨벤션 마련! -&gt; 문제가 발생하는 이유가 근본적인 원인이 아니라 현상이 아닐까?</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>문제 재정의 </p>\n<ul>\n<li>근본적인 원인은 꼭 그래야할 이유가 없음에도 불구하고 작업을 각 개발자가 수동으로 반복하고 있다.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>목표 재정의</p>\n<ul>\n<li>반복 작업과 실수 여지를 최소화할 수 있는 자동화를 만들자!</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>해결 방법</p>\n<ul>\n<li>개발하는 방식을 바꾸면, 각자 조직에서의 우선순위 바쁜 일정이 있는 입장에서 부담스러워 도입이 늦어질 수 있다. </li>\n<li>할부로 구매할 수 있는 수단을 제공하자<ul>\n<li>리모트 리소스 정의 방식 일원화 (마일스톤 1)</li>\n<li>리모트 리소스 -&gt; 리모트 훅</li>\n<li>스펙 -&gt; 리모트 리소스 서버호출 함수 생성까지 자동화 (마일스톤 2)</li>\n</ul>\n</li>\n<li>답안지 훔쳐보기<ul>\n<li>useRequest, graphql-code-generator, openapi-generator, FEConf 발표를 참고로 삽질없이\n  빠르게 작업할 수 있었다.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n","category":"React"},"posts":[{"slug":"youtube-react-flex","title":"컨퍼런스 정리 - 왜 나는 React를 사랑하는가 (1)","date":"2023.11.09","coverImage":"images/cover/react-flex.png","category":"React"},{"slug":"git-commit","title":"Git Commit 메시지 작성법","date":"2023.09.13","coverImage":"images/cover/default.png","category":"Tip"},{"slug":"testing-vanilla","title":"Vanilla JS Jest 적용해보기","date":"2023.09.06","coverImage":"images/cover/default.png","category":"JavaScript"},{"slug":"css-variable","title":"CSS 변수","date":"2023.09.02","coverImage":"images/cover/default.png","category":"HTML_CSS"},{"slug":"css-position","title":"CSS Position absolute vs fixed","date":"2023.09.01","coverImage":"images/cover/default.png","category":"HTML_CSS"},{"slug":"css-safari","title":"사파리 브라우저에서의 스크롤바 동작 없애기","date":"2023.09.01","coverImage":"images/cover/default.png","category":"HTML_CSS"},{"slug":"react-style-component","title":"React 스타일 컴포넌트 다루기","date":"2023.09.01","coverImage":"images/cover/default.png","category":"React"},{"slug":"web-lighthouse","title":"Next.js 성능 측정","date":"2023.08.28","coverImage":"images/cover/default.png","category":"React"},{"slug":"next-portal","title":"Next.js Portal 만들기","date":"2023-08-29","coverImage":"/images/cover/default.png","category":"React"},{"slug":"css-semantic","title":"시맨틱 태그 (Semantic Tag)","date":"2023-08-24","coverImage":"/images/cover/default.png","category":"HTML_CSS"},{"slug":"blog-next","title":"Next.js로 마크다운 블로그 만들기","date":"2023-08-22","coverImage":"/images/cover/blog_next.png","category":"ToyProject"},{"slug":"css-unit","title":"CSS 단위","date":"2023-08-21","coverImage":null,"category":"HTML_CSS"},{"slug":"hello-world","title":"Hello","date":"2023-08-16"},{"slug":"shortcut-mac","title":"Mac을 편하게 사용하는 방법 7가지","date":"2022-04-06 23:00:14","coverImage":"/images/cover/shortcut-mac.png","category":"Tip"},{"slug":"react-native","title":"React Native","date":"2022-03-17 14:00:00","coverImage":"/images/cover/react-native.png","category":"React"},{"slug":"modern-js","title":"모던 자바스크립트 새로운 기능","date":"2022-01-27 23:47:36","coverImage":"/images/cover/modern-js.png","category":"JavaScript"},{"slug":"codespitz-86","title":"코드스피츠 [객체지향 자바스크립트] 돌아보기","date":"2022-01-27 21:11:37","coverImage":"/images/cover/codespitz.png","category":"JavaScript"},{"slug":"eslint-prettier","title":"VSCode 에서 ESLint와 Prettier 설정방법","date":"2022-01-15 17:05:58","coverImage":"/images/cover/eslint-prettier.png","category":"Tip"},{"slug":"typescript-config","title":"TSConfig 설정방법","date":"2022-01-14 16:14:08","coverImage":"/images/cover/typescript-config.png","category":"TypeScript"},{"slug":"react-cypress","title":"React에 Cypress 적용하기","date":"2022-01-14 13:58:02","coverImage":"/images/cover/react-cypress.png","category":"React"},{"slug":"react-runtime-error","title":"React 환경세팅에서 만난 오류들","date":"2021-12-28 14:57:17","coverImage":"/images/cover/react-runtime-error.png","category":"React"},{"slug":"browser-operation","title":"브라우저 동작 원리","date":"2021-12-01 21:59:43","coverImage":"/images/cover/browser-operation.png","category":"HTML_CSS"},{"slug":"react-redux","title":"React와 Redux","date":"2021-11-26 13:45:56","coverImage":"/images/cover/react-redux.png","category":"React"},{"slug":"css-selectors","title":"CSS 선택자","date":"2021-11-12 15:12:23","coverImage":"/images/cover/css-selectors.png","category":"HTML_CSS"},{"slug":"html-span","title":"HTML <span> 요소","date":"2021-11-12 15:08:11","coverImage":"/images/cover/html-span.png","category":"HTML_CSS"},{"slug":"create-thumbnail","title":"썸네일 이미지 생성","date":"2021-11-10 17:55:44","coverImage":"/images/cover/create-thumbnail.png","category":"ToyProject"},{"slug":"react-migration","title":"React 기존 프로젝트에 타입스크립트 마이그레이션","date":"2021-11-05 00:22:39","coverImage":"/images/cover/react-migration.png","category":"React"},{"slug":"react-vac","title":"React VAC Pattern","date":"2021-11-01 16:57:17","coverImage":"/images/cover/react-vac.png","category":"React"},{"slug":"typescript","title":"TypeScript 스터디","date":"2021-11-01 14:27:36","coverImage":"/images/cover/typescript.png","category":"TypeScript"},{"slug":"vanilla","title":"Vanilla JS 다뤄보기","date":"2021-10-30 23:20:00","coverImage":"/images/cover/vanilla.png","category":"JavaScript"},{"slug":"yarn","title":"Yarn","date":"2021-10-17 15:31:01","coverImage":"/images/cover/yarn.png","category":"JavaScript"},{"slug":"port","title":"Mac에서 Port 종료하기","date":"2021-10-10 23:31:07","coverImage":"/images/cover/port.png","category":"Tip"},{"slug":"react-condition","title":"React 조건부 렌더링","date":"2021-10-03 18:38:26","coverImage":"/images/cover/react-condition.png","category":"React"},{"slug":"load-map","title":"로드맵","date":"2021-09-24 14:39:08","coverImage":"/images/cover/default.png","category":"ToyProject"},{"slug":"blog-hexo","title":"Hexo를 이용한 github 블로그 만들기","date":"2021-09-24","coverImage":"/images/cover/blog-hexo.png","category":"ToyProject"},{"slug":"good-image","title":"good-image","date":"2021-09-13 12:59:37","coverImage":"/images/cover/study.png"},{"slug":"es6","title":"ES6 문법","date":"2020-02-04","coverImage":"/images/cover/es6.png","category":"JavaScript"},{"slug":"sass","title":"Sass(SCSS) 알아가기","date":"2020-01-22","coverImage":"/images/cover/sass.png","category":"HTML_CSS"},{"slug":"vscode","title":"VS Code 활용하기","date":"2020-01-09","coverImage":"/images/cover/vscode.png","category":"Tip"},{"slug":"storage","title":"Local & Session Storage","date":"2019-11-01","coverImage":"/images/cover/storage.png","category":"HTML_CSS"},{"slug":"testing-vue","title":"Vue.js 2.x 테스트 적용기","date":"2019-10-17","coverImage":"/images/cover/testing-vue.png","category":"Vue"},{"slug":"graphql","title":"Graphql 적용기","date":"2019-10-16","coverImage":"/images/cover/graphql.png","category":"JavaScript"},{"slug":"blob","title":"Load Image File","date":"2019-10-10","coverImage":"/images/cover/blob.png","category":"JavaScript"},{"slug":"d3","title":"D3 필요한 메서드 정리해보자","date":"2019-10-01","coverImage":"/images/cover/d3.png","category":"JavaScript"},{"slug":"settings","title":"개발환경 세팅하기","date":"2019-09-26","coverImage":"/images/cover/settings.png","category":"Tip"},{"slug":"pattern","title":"Javascript 디자인패턴 이야기","date":"2019-09-11","coverImage":"/images/cover/pattern.png","category":"JavaScript"},{"slug":"promise","title":"Javascript Promise 이야기","date":"2019-08-28","coverImage":"/images/cover/promise.png","category":"JavaScript"},{"slug":"event","title":"Javascript Event 이야기","date":"2019-08-22","coverImage":"/images/cover/event.png","category":"JavaScript"},{"slug":"object","title":"Javascript Object 이야기","date":"2019-08-21","coverImage":"/images/cover/object.png","category":"JavaScript"},{"slug":"browser","title":"Browser 이야기","date":"2019-08-19","coverImage":"/images/cover/browser.png","category":"HTML_CSS"},{"slug":"array","title":"Javascript Array 이야기","date":"2019-08-18","coverImage":"/images/cover/array.png","category":"JavaScript"},{"slug":"css-grid-flex","title":"Grid 와 Flex 사용법","date":"2019-08-16","coverImage":"/images/cover/css-grid-flex.png","category":"HTML_CSS"},{"slug":"vuejs","title":"Vue 이야기","date":"2019-08-14","coverImage":"/images/cover/vue-js.png","category":"Vue"},{"slug":"npm","title":"NPM","date":"2019-08-09","coverImage":"/images/cover/npm.png","category":"JavaScript"},{"slug":"git","title":"안 쓰면 잊어버리는 Git 명령어","date":"2019-08-08","coverImage":"/images/cover/git.png","category":"Tip"},{"slug":"blog-jekyll","title":"Jekyll을 이용한 github 블로그 만들기","date":"2019-08-07","coverImage":"/images/cover/blog-jekyll.png","category":"ToyProject"},{"slug":"canvas","title":"Canvas로 그래프 그리기","date":"2019-06-10","coverImage":"/images/cover/canvas.png","category":"HTML_CSS"}]},"__N_SSG":true}