<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="viewport-fit=cover"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/6eca03e35c9c9eae.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6eca03e35c9c9eae.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-63157d71ad419e09.js" defer=""></script><script src="/_next/static/chunks/main-2f1c90f15011e7a4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-220f73948b70f663.js" defer=""></script><script src="/_next/static/chunks/23-1e1b6cd9f6a2e676.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-eb045ea4ab526c15.js" defer=""></script><script src="/_next/static/GooIiPSF99HtY3NMbDDyv/_buildManifest.js" defer=""></script><script src="/_next/static/GooIiPSF99HtY3NMbDDyv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="sc-986ff7fc-0 imLcot"><nav class="sc-986ff7fc-1 eEnMlM"><div class="sc-986ff7fc-2 iVcRKG"><a href="/">Home</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/React/react-condition">React</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/Vue/vuejs">Vue</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/JavaScript/es6">JavaScript</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/TypeScript/typescript">TypeScript</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/HTML_CSS/browser-operation">HTML/CSS</a></div><div class="sc-986ff7fc-2 iVcRKG"><a href="/ToyProject">Toy Project</a></div><a href="/profile"><div class="sc-986ff7fc-3 UcNoa"></div></a></nav></header><section class="sc-53569208-0 qXGRu"><h1 class="sc-53569208-1 kqSQaB">브라우저 동작 원리</h1><h6>2021-12-01 21:59:43</h6><article class="sc-53569208-2 lhbsva"><h2>브라우저의 역할</h2>
<p>브라우저는 웹페이지를 서버에 요청하고 서버의 응답을 받아 표시합니다.
서버로부터 html, css, javascript, 이미지 파일 등 응답받는 것입니다.</p>
<p>html, css 는 렌더링 엔진인 html 파서와 css 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되어 렌더 트리로 결합됩니다. 브라우저는 렌더 트리를 기반으로 웹페이지를 표시합니다.</p>
<p>크롬은 대부분의 브라우저와 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지하고 있습니다.
각 탭은 독립된 프로세스로 처리된다는 점이 장점입니다.</p>
<p>사파리와 크롬은 <a>웹킷 엔진</a>을 사용합니다.</p>
<h2>동작 과정</h2>
<h3>렌더링 엔진</h3>
<p><code>렌더링 엔진</code>은 HTML 문서를 파싱하고 "콘텐츠 트리" 내부에서 태그를 <code>DOM 노드</code>로 변환해줍니다. 그 다음 외부 CSS 파일과 함께 스타일 요소도 파싱하게 되는데 스타일 정보와 HTML 표시 규칙은 <code>렌더 트리</code>라고 부르는 또다른 트리를 생성합니다.</p>
<p><code>렌더 트리</code> 생성이 끝나면 배치(layout)가 시작되는데 각 노드가 화면의 정확한 위치에 표시는 되는 것을 의미합니다.</p>
<p><code>렌더링 엔진</code>은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 html 을 파싱할 때까지 기다리지 않고 배치(layout)와 그리기 과정을 시작합니다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시해주는 것이죠.</p>
<h3>파싱</h3>
<p>html 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어권을 넘겨줍니다. 자바스크립트 엔진은 자바스크립트 파일을 로드하고 파싱하여 실행합니다.</p>
<p>자바스크립트의 실행이 완료되면, 다시 HTML 파서로 제어권을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개합니다.</p>
<p>이처럼 브라우저는 동기적으로 html, css, javascript를 처리하게 됩니다.
그래서 흔히, body 아래에 script 써주는 방법이 dom 생성이 지연되어 발생할 수 있는 오류를 예방하는데 좋은 방법이 되었습니다.</p>
<h2>자바스크립트 엔진</h2>
<p>자바스크립트는 렌더링 엔진이 아닌 chrome 에서는 chrome v8 자바스크립트 엔진이 담당합니다.</p>
<h2>Reference</h2>
<ul>
<li><a href="https://poiemaweb.com/js-browser">https://poiemaweb.com/js-browser</a></li>
<li><a href="https://d2.naver.com/helloworld/59361">https://d2.naver.com/helloworld/59361</a></li>
</ul>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"브라우저 동작 원리","slug":"browser-operation","date":"2021-12-01 21:59:43","content":"\u003ch2\u003e브라우저의 역할\u003c/h2\u003e\n\u003cp\u003e브라우저는 웹페이지를 서버에 요청하고 서버의 응답을 받아 표시합니다.\n서버로부터 html, css, javascript, 이미지 파일 등 응답받는 것입니다.\u003c/p\u003e\n\u003cp\u003ehtml, css 는 렌더링 엔진인 html 파서와 css 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되어 렌더 트리로 결합됩니다. 브라우저는 렌더 트리를 기반으로 웹페이지를 표시합니다.\u003c/p\u003e\n\u003cp\u003e크롬은 대부분의 브라우저와 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지하고 있습니다.\n각 탭은 독립된 프로세스로 처리된다는 점이 장점입니다.\u003c/p\u003e\n\u003cp\u003e사파리와 크롬은 \u003ca\u003e웹킷 엔진\u003c/a\u003e을 사용합니다.\u003c/p\u003e\n\u003ch2\u003e동작 과정\u003c/h2\u003e\n\u003ch3\u003e렌더링 엔진\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e렌더링 엔진\u003c/code\u003e은 HTML 문서를 파싱하고 \"콘텐츠 트리\" 내부에서 태그를 \u003ccode\u003eDOM 노드\u003c/code\u003e로 변환해줍니다. 그 다음 외부 CSS 파일과 함께 스타일 요소도 파싱하게 되는데 스타일 정보와 HTML 표시 규칙은 \u003ccode\u003e렌더 트리\u003c/code\u003e라고 부르는 또다른 트리를 생성합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e렌더 트리\u003c/code\u003e 생성이 끝나면 배치(layout)가 시작되는데 각 노드가 화면의 정확한 위치에 표시는 되는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e렌더링 엔진\u003c/code\u003e은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 html 을 파싱할 때까지 기다리지 않고 배치(layout)와 그리기 과정을 시작합니다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시해주는 것이죠.\u003c/p\u003e\n\u003ch3\u003e파싱\u003c/h3\u003e\n\u003cp\u003ehtml 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어권을 넘겨줍니다. 자바스크립트 엔진은 자바스크립트 파일을 로드하고 파싱하여 실행합니다.\u003c/p\u003e\n\u003cp\u003e자바스크립트의 실행이 완료되면, 다시 HTML 파서로 제어권을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개합니다.\u003c/p\u003e\n\u003cp\u003e이처럼 브라우저는 동기적으로 html, css, javascript를 처리하게 됩니다.\n그래서 흔히, body 아래에 script 써주는 방법이 dom 생성이 지연되어 발생할 수 있는 오류를 예방하는데 좋은 방법이 되었습니다.\u003c/p\u003e\n\u003ch2\u003e자바스크립트 엔진\u003c/h2\u003e\n\u003cp\u003e자바스크립트는 렌더링 엔진이 아닌 chrome 에서는 chrome v8 자바스크립트 엔진이 담당합니다.\u003c/p\u003e\n\u003ch2\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://poiemaweb.com/js-browser\"\u003ehttps://poiemaweb.com/js-browser\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://d2.naver.com/helloworld/59361\"\u003ehttps://d2.naver.com/helloworld/59361\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","category":"HTML_CSS"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"browser-operation"},"buildId":"GooIiPSF99HtY3NMbDDyv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>