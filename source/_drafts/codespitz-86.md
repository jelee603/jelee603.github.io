---
title: 코드스피츠 객체지향 자바스크립트
tags:
thumbnail: '/images/codespitz.png'
categories: 'JavaScript'
comments: false
---

[코드스피츠 86 - 객체지향 자바스크립트](https://www.youtube.com/watch?v=E9NZ0YEZrYU&list=PLBNdLLaRx_rIRXCp9tKsg7qDQmAX19ocw) 강의를 보면서 정리한 내용을 적습니다.

5회차 강의고, 1회차부터 순차적으로 정리해봅니다.

### 1일차

Value Context: 메모리 주소에 관계없이 값이 같다고 보면 같은 것이라 보는 관점 (값 기반)

- 할당하거나 가져올 때, 값을 사용한 경우는 끝없이 복사본을 만든다.
- 상태가 관리되서 안전한게 아니라, 계속 불변하는 값들을 만들어내서 안전해 보이는 것일뿐
- 연산을 기반으로 로직을 전개

identifier Context: 힙 메모리에 있는 주소로 보는 관점 (식별 기반)

하나의 컨텍스트만 쓰는 것을 권장.

```
// 오브젝트 객체의 리터럴로 값을 만듦
const a = {
 a: 3,
 b: 5
}

const b = {
 a: 3,
 b: 5
}

console.log(a === b) // false (indentify context 기준으로 메모리의 주소를 보면 다른 값이다)
console.log(JSON.stringify(a) === JSON.stringify(b)) // true (문자열로 환원하면, 값으로 보는것이라 같다)
```

#### 객체지향 세계

- 하나의 원본

- 내부의 상태관리를 책임지는 객체
- 메시지를 통해서 위임해서 로직을 전개

- 객체 지향은 value context 를 쓰지 않는다.

> 업계에서 사용하는 고유명사를 외운다.

#### Polymorphism

1. substitution (대체 가능성)

   - 확장된 객체는 원본으로 대체 가능 (자식은 부모를 대신할 수 있다.)

2. internal identity (내적일관성)
   - 생성 시점의 타입이 내부에 일관성있게 참조된다. (어느시점에서든 만들어질 때 상태를 유지한다)

ex) 오버라이딩: 부모함수를 덮어서 없애고 자식함수로 대체하는 것

```js
const Worker = class {
  run() {
    console.log('working');
  }
  print() {
    this.run();
  }
};

const HardWorker = class extends Worker {
  // 하드워커의 부분집합이 워커, 확장될 클래스는 확장할 대상을 대체할 수 있다.
  run() {
    console.log('hardWorking');
  }
};

const worker = new HardWorker(); // 워커의 인스턴스로 하드워커를 만듬
console.log(worker instanceof Worker); // substitution
worker.print(); // internal identity
```

> ES6 (2015) , ES2020 새로운 문법..

#### Object Essentials (객체의 본질)

1. Maintenance of State (데이터를 은닉) : 객체의 속성이 모두 프라이빗이면서 내 데이터를 관리한다.
2. Encapsulation of Functionality (기능의 캡슐화) : 메소드를 감춘다. 외부에 캡슐화해서 제공한다.
3. Isolation of change (격리) : 변화의 여파를 막고 격리시킨다. 오염시켰을 때, 전역 처리기를 걸어둔다.

```
const EssentialObject = class {
	#name = ""; // hide state
	#screen = null;
	constructor(name) {
		this.#name = name;
	}
	camouflage() {
		this.#screen = (Math.random() * 10).toString(16).replace(".", "")
	}
	get name() {
		return this.#screen || this.#name;
	}
}
```

> 연역적 사고와 귀납적 사고를 추론하는 연습을 하고, 감성적인 코드가 들어갈 필요가 없는 분야다. 개인을 개입하면 계속 어려우니, 훈련을 하자.
> 연역적 추리(몇가지만 다르다는 것만 찾으면 된다)로 케이스로부터 원리를 도출하는 것을 의미한다.

#### 알려진 기본 설계요령

SOLID 원칙 - 로버트 마틴

- SRP (Single Responsibility) 단일책임

코드를 고쳐야하는 이유는 하나뿐이야라고 만드는 방법, 잘못하게 되면 산탄총 수술이 필요하다.

다른 객체에게 위뢰한다 = 다른 객체에게 메시지를 보내는 것.

- OCP (Open Closed) 개방폐쇄

기존의 객체를 건드리지 않게 설계를 해야한다. 새로운 문제가 일어났으면 새로운 객체를 만들어서 새로운 것에 대한 해결책만 내리면된다.

인터페이스나 추상클래스를 상속받아서 처리한다. 그 다음번 문제도 추상화를 받아서 해결한다.

- LSP (Liskov Substitusion, 리스코프 치환) 업캐스팅 안전해야한다.

부모쪽으로 캐스팅해서 형을 변환하는 것.

Ex) 추상층: 생물(숨을 쉰다) 구상층: 사람(생물, 다리로 이동한다), 타조(생물, 다리로 이동한다), 아메바(생물)

- ISP (Interface Substitusion, ISP 치환) 인터페이스 분리

리스코프 치환법칙을 위반하면 인터페이스로 분리한다. 똑같은 위치에서 같은 기능을 하는 경우에 위임이 불가능할 경우.

역할에 맞게 분리해서 만들어야한다. 객체의 변화가 모듈과 모듈에 관련된 인터페이스로만 분산시키는 것.

1. 소유 방법으로 분리한다.
2. 인터페이스를 만들어서 오버라이딩하면 된다.

- DIP (Dependency Inversion) 다운캐스팅 금지

의존성 역전의 법칙, 의존성은 항상 부모에서 자식으로만 상속된다.

폴리모피즘(추상인터페이스) 사용

```js
const Manager = class {
  #workers;
  constructor(...workers) {
    if (workers.every((w) => w instanceof Worker)) this.#workers = workers;
  }
  doWork() {
    this.#workers.forEach((w) => w.run());
  }
};

const manager = new Manager(new Worker(), new HardWorker());
manager.doWork();
```

> 1. DI (Dependency Injection) 의존성 주입
> 2. DRY 중복방지
> 3. Hollywood Principle 의존성 부패방지
>  물어보지 말고 요청하지 마라. ex) 시간날 때, 나한테 연락을 줘.
> 4. Law of demeter 최소 지식
>  최소한의 지식만 가지고, 내부에서 객체의 타입, 원래 필드의 타입, 인자로 가져온 객체의 타입만 알게 하자.
>  너무 많아지면, train wreck (열차전복) 현상이 일어난다.
> 5. Inversion Of Control 제어 역전
>  flow control (흐름 제어) = 역으로 대치하 겠다. 즉, 위임하겠다라는 의미
>  프로그램 실행 통제 : 어떠한 흐름으로 제어할지 결정하는 것
>  제어를 추상화하고 제어문을 한번만 작성하면, 일반화한다.
>  개별 제어의 차이점만 외부에서 주입한다.
>  실제구현: 전략패턴 & 템플릿 메소드 패턴 < 컴포지트 패턴 < 비지터 패턴

#### SRP 준수하는 객체망이 문제를 해결하는 방법은?

다른 객체에게 의뢰한다.

1. 메시지 - 의뢰할 내용
2. 오퍼레이션 - 메시지를 수신할 객체가 제공하는 서비스
3. 메소드 - 오퍼레이션이 연결될 실제 처리기

#### 의존성의 종류

객체의 생명 주기 전체에 걸친 의존성

- 상속(extends)
- 연관(association) : 상속을 소유를 한다.
- 의존성이 높거나 역할을 개개인별로 너무 많이 부여하면 모두 퇴사한다.
- 부모는 방탄이다.
- 필드의 객체 타입을 알고 있다.

각 오퍼레이션 실행 시 임시적인 의존성

- 의존성(dependency) : 연관에서 의존성 함수로 바꾸어라. 의존성을 낮추라.

수정하기 어려운 구조 생성, if 로 감싸고 모두 분기친다.

수정 여파 규모증가하면서 순환 의존성으로 모두 망가진다.

객체지향 방법론을 배우고 변화에 대한 격리를 하기 위해서 배운다. 다른 건 회귀테스트 돌리면 안전할 수 있다는 걸 보장받기 위해. (5년 공부하면..)

> 코드에는 충분한 의도를 표현할 수 있다.

---
### 2일차

MVVM 실습해보고 점진적으로 수정해가는 과정을 배운다.

#### MVC

Model -> Controller -> View -> Model

뷰가 모델을 알고 있는 것이 문제, 모델은 비지니스 모델인데 화면에 표시되는 이유와 너무 다르다.

서로 의존적이라는게 가장 문제가 있다. 모델의 변화와 뷰의 변화가 매우 밀접.

서버에서는 컨트롤러로 가공하는 방법이라 괜찮은데 클라에서는 양방향이 서로 연동되면 안되서 문제가 된다.

#### 제왕적 컨트롤러 MVC

View -> Controller -> Model -> Controller -> View

뷰가 컨트롤러를 통해 모델을 바꾸고 뷰의 변화나 모델의 변화가 필요할 때, 컨트롤러를 짜게 된다.

#### MVP

View (getter, setter) - Presenter -> Model -> Presenter -> View (getter, setter)

뷰는 프로그래밍이 인터페이스로써 세터와 게터가 있다.

프레젠터 입장에서는 뷰의 게터, 세터를 호출한다. 사실 모델을 모르고 호출하게 된다. 뷰가 모델을 건드릴 수가 없다.

프레젠터는 통제만 한다.

#### MVVM

View <- Binder(옵저버) -> ViewModel -> Model -> ViewModel

뷰모델은 순수한 뷰이다. 뷰의 변화가 있으면 바인더가 뷰모델을 갱신해준다. 진짜 뷰와 뷰모델의 의존성을 바인더가 컨트롤한다.

뷰모 델이 뷰를 완전히 모르게 한다.

#### TypeCheck

자바스크립트는 런타임에 에러가 발견되는 즉시, throw로 멈추게 해야한다.

```
typeof type == 'string' // type 이 string 이 아니면 객체이다.
```

동등 연산자는(==) 강제 형변환을 일으키지 않아서 속도가 빠르다. 그래서 미리 체크하는 함수를 만들어서 사용하면 매번 일치 연산자(===) 로 비교하는 작업을 줄일 수 있다. 일치 연산자는 자료형 검사를 먼저하게 되서 속도가 느리다.

#### View hook & bind

어떤 뷰 모델과 매칭할지 훅이 필요하다.

HTML5 에서는 'data-' 만들지 않는 속성은 유효성 검사에서 모두 깨지게 되어있다.

https://validator.w3.org/#validate_by_uri

bind 는 내부의 훅과 뷰모델을 연결해서 반영해준다.

#### Role Design

바인더는 현재의 뷰모델을 이용해서 스캔했던 뷰를그려주는 역할만 한다.

바인딩에는 2가지 방식있다.

1. 태그를 스캔하게 만들어서 만드는 방식, 뷰와 모델을 분리해서 관리할 수 있다. (앵귤러의 방식)
2. 데이터와 연결되어 있는 뷰를 만들어서 이 뷰를 꽂게하는 컴포넌트 방식, 자기 뷰를 모델과 연결해서 만들어둔다. (리액트의 방식)

#### MVVM Example

![전략 패턴](ex-2.png)

- 1차 개발 - SRP (Single Responsibility) 단일책임

Scanner 를 따로 만들어둔다.

변경주기에 따라 바인더가 HTML을 바꾸는 것보다는 HTML 해석 스캐너를 따로 둔다.

HTML 을 해석했을 때, 변경이 일어나면 바꿀 수 있게 하기위함이다. (객체마다 변화하는 이유를 하나만 만들고 싶어서)

ViewMode <- Binder[BinderItem] <- Scanner -> HTMLElement

1. 뷰모델을 먼저 만든다. [[강의]](https://youtu.be/RT38Za1pkdI?list=PLBNdLLaRx_rIRXCp9tKsg7qDQmAX19ocw&t=2463)

커스텀 키를 만들 수 있도록 한다. 값은 추가할 수 있다.

키는 DOM 의 프로퍼티와 어트리뷰트 값을 업데이트 할 수 있다.

- 프로퍼티 엘리먼트에 사용하는 것

- 어트리뷰트 태그에 사용하는 것

뷰모델을 이용해서 뷰를 업데이트 하게끔 만든다.

2. 바인더를 만든다 [[강의]](https://youtu.be/RT38Za1pkdI?list=PLBNdLLaRx_rIRXCp9tKsg7qDQmAX19ocw&t=2908)

- 뷰를 그리는 제어문은 바인더가 가져갔다. - ISP 제어역전이 성립한다

- 데이터를 조작하는 코드만 필요하고 뷰를 그리는 코드는 신경을 안써도 됨

- 바인딩 작업후에 바뀌지 않았으면 좋겠다고 생각할 때, freeze

> 자바스크립트는 언어의 표현이 풍부하고 언어 디자이너들이 만든 기본값 시스템들을 잘 활용해야한다.

3. 스캐너를 만든다 [[강의]](https://youtu.be/RT38Za1pkdI?list=PLBNdLLaRx_rIRXCp9tKsg7qDQmAX19ocw&t=3955)

특정 HTML 을 스캔해서 hook 을 만들어줘서 바인더에 연결해주는 작업을 한다.

재귀라는 건 함수가 함수를 부르는 행위인데 함수 한번 임시 메모리에 쌓으면 스택 오버 플로우가 발생한다.

해결하려면, 별도의 메모리 공간 스택을 만들고 while로 돌면서 처리를 하면된다.

동적으로 스택을 빼가면서 만든다.

> 똑같은 문제를 여러번 풀어봐야한다. 어려운 과제를 푸는데 성공한 것만으로는 실력이 되지 않는다. 기억하고 만들어서 쓸 수 있는건 숙련도의 문제이다. 많이 수련하고, 어려운 거 쉬운거 할 거 없이 내꺼가 될때까지 연습해야한다.

4. ViewModel 을 개선 [[강의]](https://youtu.be/RT38Za1pkdI?list=PLBNdLLaRx_rIRXCp9tKsg7qDQmAX19ocw&t=4770)

style, attribute 가 아닌건 key로 잡아준다.

클릭했을 때 이벤트를 추가한다.

wrapper 랑 contents 를 바꾼 후에 한번만 렌더를 한다.

뷰를 컨트롤하는 제어역전으로 binder 로 보내버렸다. 뷰모델만 검사하면 된다.

모델을 바꿔서 렌더를 그린다. -> (모델 렌더로 변경)

> 객체의 역할로 나눠보고, MVVM 구축하는 과정을 배운다. 객체 구조를 아는 것이 뷰마다 뷰를 그리는 로직을 없앤다. 뷰를 그리는 객체를 모델을 만들어서 생명주기, 변화율에 따른 의존성을 분리한다.


---
### 3일차

기존 바인더 코드를 전략적으로 변경하는 방법
![전략 패턴](ex-3.png)
#### 전략 패턴 (Strategy)

어떤 문제를 해결하기 위한 핵심적인 지식적인 부분. 도메인만의 지식. 

객체는 상태는 프로퍼티로 행동은 메소드로 표현한다.

Binder 변경

1. 변화가 생길 때마다 코드를 변경하는게 아니라 객체로 변경하기 (컴포지션 패턴 -> DI)

   - 내부에서 만들면 다시 하드코딩이다. (Dependency)

   -  코드를 변경하지 않고 외부에서 공급받으면 객체에 대한 의존성을 줄일 수 있다. (DI)

2. 반드시 인터페이스나 타입으로 변환해야한다. 
3. 내부의 코드를 프로세서와의 계약으로 풀었기 때문에 프로세서로 풀어준다.(알고리즘의 일반화)

> 공통로직으로 묶고, 타입이 제공하는 메소드로만 알고리즘을 수정하는 것 -> 알고리즘의 일반화
>
> 안보고 짜는 걸 10번 정도 연습한다.


#### 템플릿 패턴

Processor 생성

- 자식한테 위임하는 방법 (템플릿 메소드 -> `hook` 이라 부른다.)

> 알고리즘은 구조와 관련이 있다.


#### 옵저버 패턴 (Observer)

감시하는 쪽(observer)은 수신하는 observe는 편하다. 

감시 당하는 쪽(subject)은 변화가 일어나면 notify 로 알려줘야해서 subject 가 더 피곤하다.

> IE 9 까지 제공하거나 갤럭시 노트 3.. 지원하려면 ES5로 제공해야한다.
> Proxy는 바벨로 컨버팅이 안된다.  


1. ViewModel 변경

notification 을 줄 수 있게 변경하기

defineProperties 로 만들어서 쓴다. 타겟이되는 결과 오브젝트를 받아서 해석한 후 프로퍼티로 세팅해준다. 원본 오브젝트의 key, value 로 돌면서 만들어준다.

> reduce 는 초기값은 두고 첫번째 인자 accumulator 가 계속 앞에 인자로 들어오고 두번째 인자는 배열의 원소들이 들어온다. 그 다음에 있는  accumulator 있는 건 함수가 반환하는 값으로 변경된다. 오브젝트로 반환 될거다. ex) Object.entries().reduce(() => {}, {})


2. Binder 변경

ViewModelListener 의 책임도 생긴다. 

인터페이스 별로 분리해줘야한다. watch, unwatch 로 등록해서 뷰모델을 받아서 noti가 안 왔을 때, 렌더를 해준다. 

특정 리스너를 등록해준다. 


> 공간 복잡도로 풀 건가 시간 복잡도로 풀 건가를 고민해야한다. 

#### 컴포지트 패턴 (Composite)

동일한 문제를 위임을 반복해서 취합하는 방법을 말한다.

1. 뷰모델인 자신이 자식 뷰모델을 옵저버가 되야한다. 

   자신의 변화를 알아차려야하므로, 뷰모델의 리스너가 되야한다. 리스너가 아닐 때까지 계속 반복한다. 

  	 백바인드를 걸어준다.

2. 옵저버 패턴의 인포 객체가 넘어오면 이벤트를 알아야한다. 

​   이벤트 객체의 타겟을 얻어서 하는 것이 info 객체의 충분한 메소드를 받지 못해서 subject 를 참조하게 된다. 밸런스를 잘 맞추는 것을 디자인 결정을 내려야한다. 

​   subKey 를 걸어준다. 

3. 리퀘스트 애니메이션 프레임 당 모든 걸 취합해서 notifiction 한번만 보내준다.

vm 커버하는 단일 루프 하나에 등록해서 쓴다. 배열 루프가 훨씬 빠르다. (리스너를 100개 다는 것보다 리스너 1개만 걸고 루프 돌리는게 훨씬 빠름)

> 계속 하다보면 쉬워진다. 그래프 순회나 재귀로 푸는 것보다 컴포지트 패턴이 훨씬 쉽게 풀린다. 


#### 비지터 패턴

2개 이상의 알고리즘에 개입하는 외부에서 공급되는 전략

단일 컨트롤, 다양한 메서드 다른 곳에서 역할 수행하는 경우에 모두 비지터의 가능성. 


 #### Client

뷰모델의 부모의 isStop 을 업데이트해준다.

>  MVVM 은 뷰모델만 수정하면 된다. 

